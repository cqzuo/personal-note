本文由oouqivi43531贡献
rtf文档可能在WAP端浏览体验不佳。建议您优先选择TXT，或下载源文件到本机查看。
本章介绍Java的实用工具类库java.util包。在这个包中，Java提供了一些实用的方法和 数据结构。例如，Java提供日期(Data)类、日历(Calendar)类来产生和获取日期及时间， 提供随机数(Random)类产生各种类型的随机数，还提供了堆栈(Stack)、向量(Vector) 、 位集合(Bitset)以及哈希表(Hashtable)等类来表示相应的数据结构。 　　图1.1给出了java.util包的基本层次结构图。下面我们将具体介绍其中几个重要的 类。 　　　　　　　　　　　┌java.util.BitSet 　　　　　　　　　　　│java.util.Calendar 　　　　　　　　　　　│　　　　　　└java.util.GregorianCalendar 　　　　　　　　　　　│java.util.Date 　　　　　　　　　　　│java.util.Dictionary 　　　　　　　　　　　│　　　　　　└java.util.Hashtable 　　　　　　　　　　　│　　　　　　　　　　　　　└java.util.Properties 　　　　　　　　　　　│java.util.EventObject 　　　　　　　　　　　│java.util.ResourceBundle 　　　　　　　┌普通类┤　　　　　　├java.util.ListResourceBundle 　　　　　　　│　　　│　　　　　　└java.util.PropertyResourceBundle 　　　　　　　│　　　│java.util.Local 　　　　　　　│　　　│java.util.Observable 　　　　　　　│　　　│java.util.Random 　　　　　　　│　　　│java.util.StringTokenizer 　　　　　　　│　　　│java.util.Vector 　　　　　　　│　　　│　　　　　　└java.util.Stack 　　Java.util┤　　　└java.util.TimeZone 　　　　　　　│　　　　　　　　　　└java.util.SimpleTimeZone 　　　　　　　│　　　┌java.util.Enumeration 　　　　　　　├接　口┤java.util.EventListener 　　　　　　　│　　　└java.util.Observer 　　　　　　　│　　　┌java.util.EmptyStackException 　　　　　　　└异常类┤java.util.MissingResourceException 　　　　　　　　　　　│java.util.NoSuchElementException 　　　　　　　　　　　└java.util.TooManyListenersException 　　　　　　　图1.1 java.util包的基本层次结构
在进行Java开发时，常常要使用一些数据集合,JDK为我们提供了一系列应用类来实现基本 的数据结构。这些类均在java.util包中。简单描述一下: Collection List LinkedList ArrayList Vector Stack Set Map Hashtable HashMap WeakHashMap Collection接口 　　Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的 元素（Elements）。一些Collection允许相同的元素而另一些不行。一些能排序而另一些
不行。Java SDK不提供直接继承自Collection的类，Java SDK提供的类都是继承自 Collection的“子接口”如List和Set。 　　所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用 于创建一个空的Collection，有一个Collection参数的构造函数用于创建一个新的 Collection，这个新的Collection与传入的Collection有相同的元素。后一个构造函数允 许用户复制一个Collection。 　　如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一 个iterator()的方法，该方法返回一个迭代器，使用迭代器可访问Collection中每一个元 素。用法如下： 　　　　Iterator it = collection.iterator(); // 获得一个迭代器 　　　　while(it.hasNext()) { 　　　　　　Object obj = it.next(); // 得到下一个元素 　　　　} 　　由Collection接口派生的两个接口是List和Set。 List接口 　　List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能 够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于 Java的数组。 和下面要提到的Set不同，List允许有相同的元素。　　除了具有Collection接口必备的 iterator()方法外，List还提供一个listIterator()方法，返回一个ListIterator接口， 和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删 除，设定元素，还能向前或向后遍历。 　　实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。 LinkedList类 　　LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get， remove，insert方法在LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈 （stack），队列（queue）或双向队列（deque）。 　　注意LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访 问同步。一种解决方法是在创建List时构造一个同步的List： 　　　　List list = Collections.synchronizedList(new LinkedList(...)); ArrayList类 　　ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同 步。 size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n 个元素需要O(n)的时间。其他的方法运行时间为线性。 　　每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这 个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元 素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。 和LinkedList一样，ArrayList也是非同步的（unsynchronized）。 Vector类 　　Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然 和ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator 被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元 素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须 捕获该异常。 Stack 类 　　Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得 Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素， empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后 是空栈。
Set接口 　　Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals (e2)=false，Set最多有一个null元素。 　　很明显，Set的构造函数有一个约束条件，传入的Collection参数不能包含重复的元 素。 　　请注意：必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改 变了自身状态导致Object.equals(Object)=true将导致一些问题。 Map接口 　　请注意，Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能 包含相同的key，每个key只能映射一个value。Map接口提供3种集合的视图，Map的内容可 以被当作一组key集合，一组value集合，或者一组key-value映射。 Hashtable类　　Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空 （non-null）的对象都可作为key或者value。 　　添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开 销为常数。 Hashtable通过initial capacity和load factor两个参数调整性能。通常缺省的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查 找时间将增大，这会影响像get和put这样的操作。 使用Hashtable的简单示例如下，将1，2，3放到Hashtable中，他们的key分别是” one”，”two”，”three”： 　　　　Hashtable numbers = new Hashtable(); 　　　　numbers.put(“one”, new Integer(1)); 　　　　numbers.put(“two”, new Integer(2)); 　　　　numbers.put(“three”, new Integer(3)); 　　要取出一个数，比如2，用相应的key： 　　　　Integer n = (Integer)numbers.get(“two”); 　　　　System.out.println(“two = ” + n); 　　由于作为key的对象将通过计算其散列函数来确定与之对应的value的位置，因此任何 作为key的对象都必须实现hashCode和equals方法。hashCode和equals方法继承自根类 Object，如果你用自定义的类当作key的话，要相当小心，按照散列函数的定义，如果两 个对象相同，即obj1.equals(obj2)=true，则它们的hashCode必须相同，但如果两个对象 不同，则它们的hashCode不一定不同，如果两个不同对象的hashCode相同，这种现象称为 冲突，冲突会导致操作哈希表的时间开销增大，所以尽量定义好的hashCode()方法，能加 快哈希表的操作。 　　如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果（期待的 get方法返回null），要避免这种问题，只需要牢记一条：要同时复写equals方法和 hashCode方法，而不要只写其中一个。 　　Hashtable是同步的。 HashMap类 　　HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即 null value和null key。，但是将HashMap视为Collection时（values()方法可返回 Collection），其迭代子操作时间开销和HashMap的容量成比例。因此，如果迭代操作的 性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。 WeakHashMap类 　　WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外 部所引用，那么该key可以被GC回收。 总结 　　如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应 该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。 　　如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效 率较高，如果多个线程可能同时操作一个类，应该使用同步的类。
　　要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。 　　尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将 ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。
ArrayList是List接口的一个可变长数组实现。实现了所有List接口的操作，并允许存储 null值。除了没有进行同步，ArrayList基本等同于Vector。在Vector中几乎对所有的方 法都进行了同步，但ArrayList仅对writeObject和readObject进行了同步，其它比如add (Object)、remove(int)等都没有同步。 1.存储 ArrayList使用一个Object的数组存储元素。 private transient Object elementData[]; ArrayList实现了java.io.Serializable接口，这儿的transient标示这个属性不需要自动 序列化。下面会在writeObject()方法中详细讲解为什么要这样作。 2.add和remove
public boolean add(Object o) { ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = o; return true; } 注意这儿的ensureCapacity()方法，它的作用是保证elementData数组的长度可以容纳一 个新元素。在“自动变长机制”中将详细讲解。 public Object remove(int index) { RangeCheck(index); modCount++; Object oldValue = elementData[index]; int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work return oldValue; } RangeCheck()的作用是进行边界检查。由于ArrayList采用一个对象数组存储元素，所以 在删除一个元素时需要把后面的元素前移。删除一个元素时只是把该元素在elementData 数组中的引用置为null，具体的对象的销毁由垃圾收集器负责。 modCount的作用将在下面的“iterator()中的同步”中说明。 注：在前移时使用了System提供的一个实用方法：arraycopy()，在本例中可以看出 System.arraycopy()方法可以对同一个数组进行操作，这个方法是一个native方法，如果 对同一个数组进行操作时，会首先把从源部分拷贝到一个临时数组，在把临时数组的元素 拷贝到目标位置。
3.自动变长机制 在实例化一个ArrayList时，你可以指定一个初始容量。这个容量就是elementData数组的 初始长度。如果你使用： ArrayList list = new ArrayList(); 则使用缺省的容量：10。 public ArrayList() { this(10); } ArrayList提供了四种add()方法， public boolean add(Object o) public void add(int index, Object element) public boolean addAll(Collection c) public boolean addAll(int index, Collection c) 在每一种add()方法中，都首先调用了一个ensureCapacity(int miniCapacity)方法，这 个方法保证elementData数组的长度不小于miniCapacity。ArrayList的自动变长机制就是 在这个方法中实现的。 public void ensureCapacity(int minCapacity) { modCount++; int oldCapacity = elementData.length; if (minCapacity > oldCapacity) { Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity < minCapacity) newCapacity = minCapacity; elementData = new Object[newCapacity]; System.arraycopy(oldData, 0, elementData, 0, size); } } 从这个方法实现中可以看出ArrayList每次扩容，都扩大到原来大小的1.5倍。 每种add()方法的实现都大同小异，下面给出add(Object)方法的实现： public boolean add(Object o) { ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = o; return true; }
4.iterator()中的同步 在父类AbstractList中定义了一个int型的属性：modCount，记录了ArrayList结构性变化
的次数。 protected transient int modCount = 0; 在ArrayList的所有涉及结构变化的方法中都增加modCount的值，包括：add()、remove ()、addAll()、removeRange()及clear()方法。这些方法每调用一次，modCount的值就加 1。 注：add()及addAll()方法的modCount的值是在其中调用的ensureCapacity()方法中增加 的。 AbstractList中的iterator()方法（ArrayList直接继承了这个方法）使用了一个私有内 部成员类Itr，生成一个Itr对象（Iterator接口）返回： public Iterator iterator() { return new Itr(); } Itr实现了Iterator()接口，其中也定义了一个int型的属性：expectedModCount，这个属 性在Itr类初始化时被赋予ArrayList对象的modCount属性的值。 int expectedModCount = modCount; 注：内部成员类Itr也是ArrayList类的一个成员，它可以访问所有的AbstractList的属性 和方法。理解了这一点，Itr类的实现就容易理解了。 在Itr.hasNext()方法中： public boolean hasNext() { return cursor != size(); } 调用了AbstractList的size()方法，比较当前光标位置是否越界。 在Itr.next()方法中，Itr也调用了定义在AbstractList中的get(int)方法，返回当前光 标处的元素： public Object next() { try { Object next = get(cursor); checkForComodification(); lastRet = cursor++; return next; } catch(IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } 注意，在next()方法中调用了checkForComodification()方法，进行对修改的同步检查： final void checkForComodification() { if (modCount != expectedModCount)
throw new ConcurrentModificationException(); } 现在对modCount和expectedModCount的作用应该非常清楚了。在对一个集合对象进行跌代 操作的同时，并不限制对集合对象的元素进行操作，这些操作包括一些可能引起跌代错误 的add()或remove()等危险操作。在AbstractList中，使用了一个简单的机制来规避这些 风险。这就是modCount和expectedModCount的作用所在。 5.序列化支持 ArrayList实现了java.io.Serializable接口，所以ArrayList对象可以序列化到持久存储 介质中。ArrayList的主要属性定义如下： private static final long serialVersionUID = 8683452581122892189L; private transient Object elementData[]; private int size; 可以看出serialVersionUID和size都将自动序列化到介质中，但elementData数组对象却 定义为transient了。也就是说ArrayList中的所有这些元素都不会自动系列化到介质中。 为什么要这样实现？因为elementData数组中存储的“元素”其实仅是对这些元素的一个 引用，并不是真正的对象，序列化一个对象的引用是毫无意义的，因为序列化是为了反序 列化，当你反序列化时，这些对象的引用已经不可能指向原来的对象了。所以在这儿需要 手工的对ArrayList的元素进行序列化操作。这就是writeObject()的作用。 private synchronized void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{ // Write out element count, and any hidden stuff s.defaultWriteObject(); // Write out array length s.writeInt(elementData.length); // Write out all elements in the proper order. for (int i=0; i<size; i++) s.writeObject(elementData[i]); } 这样元素数组elementData中的所以元素对象就可以正确地序列化到存储介质了。 对应的readObject()也按照writeObject()方法的顺序从输入流中读取： private synchronized void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in size, and any hidden stuff s.defaultReadObject(); // Read in array length and allocate array int arrayLength = s.readInt(); elementData = new Object[arrayLength]; // Read in all elements in the proper order. for (int i=0; i<size; i++) elementData[i] = s.readObject(); }
本章介绍Java的实用工具类库java.util包。在这个包中，Java提供了一些实用的方法和 数据结构。例如，Java提供日期(Data)类、日历(Calendar)类来产生和获取日期及时间， 提供随机数(Random)类产生各种类型的随机数，还提供了堆栈(Stack)、向量(Vector) 、 位集合(Bitset)以及哈希表(Hashtable)等类来表示相应的数据结构。 　　图1.1给出了java.util包的基本层次结构图。下面我们将具体介绍其中几个重要的 类。 　　　　　　　　　　　┌java.util.BitSet 　　　　　　　　　　　│java.util.Calendar 　　　　　　　　　　　│　　　　　　└java.util.GregorianCalendar 　　　　　　　　　　　│java.util.Date 　　　　　　　　　　　│java.util.Dictionary 　　　　　　　　　　　│　　　　　　└java.util.Hashtable 　　　　　　　　　　　│　　　　　　　　　　　　　└java.util.Properties 　　　　　　　　　　　│java.util.EventObject 　　　　　　　　　　　│java.util.ResourceBundle 　　　　　　　┌普通类┤　　　　　　├java.util.ListResourceBundle 　　　　　　　│　　　│　　　　　　└java.util.PropertyResourceBundle 　　　　　　　│　　　│java.util.Local 　　　　　　　│　　　│java.util.Observable 　　　　　　　│　　　│java.util.Random 　　　　　　　│　　　│java.util.StringTokenizer 　　　　　　　│　　　│java.util.Vector 　　　　　　　│　　　│　　　　　　└java.util.Stack 　　Java.util┤　　　└java.util.TimeZone 　　　　　　　│　　　　　　　　　　└java.util.SimpleTimeZone 　　　　　　　│　　　┌java.util.Enumeration 　　　　　　　├接　口┤java.util.EventListener 　　　　　　　│　　　└java.util.Observer 　　　　　　　│　　　┌java.util.EmptyStackException 　　　　　　　└异常类┤java.util.MissingResourceException 　　　　　　　　　　　│java.util.NoSuchElementException 　　　　　　　　　　　└java.util.TooManyListenersException 　　　　　　　图1.1 java.util包的基本层次结构
1.2 日期类Date 　　Java在日期类中封装了有关日期和时间的信息，用户可以通过调用相应的方法来获取 系统时间或设置日期和时间。Date类中有很多方法在JDK1.0公布后已经过时了，在8.3中 我们将介绍JDK1.0中新加的用于替代Date的功能的其它类。 　　在日期类中共定义了六种构造函数。 　　(1)public Date() 　　创建的日期类对象的日期时间被设置成创建时刻相对应的日期时间。 　　例 Date today=new Date()；//today被设置成创建时刻相对应的日期时间。 　　(2)public Date (long date) 　　long 型的参数date可以通过调用Date类中的static方法parse(String s)来获得。 　　例 long l=Date.parse("Mon 6 Jan 1997 13:3:00"); 　　　　Date day=new Date(l); 　　//day中时间为1997年 1月6号星期一，13:3:00。 　　(3)public Date(String s) 　　按字符串s产生一日期对象。s的格式与方法parse中字符串参数的模式相同。
　　例 Date day=new Date("Mon 6 Jan 1997 13:3:00"); 　　//day 中时间为1997年1月6号星期一，13:3:00. 　　(4)public Date(int year,int month,int date) 　　(5)public Date(int year,int month,int date,int hrs,int min) 　　(6)public Date(int year,int month,int date,int hrs,int min,int sec) 　　按给定的参数创建一日期对象。 　　参数说明： 　　year的值为：需设定的年份-1900。例如需设定的年份是1997则year的值应为97，即 1997-1900的结果。所以Date中可设定的年份最小为1900； 　　month的值域为0～11，0代表1月，11表代表12月； 　　date的值域在1～31之间； 　　hrs的值域在0～23之间。从午夜到次日凌晨1点间hrs=0，从中午到下午1点间hrs= 12； 　　min和sec的值域在0～59之间。 　　例 Date day=new Date(11,3,4); 　　//day中的时间为：04-Apr-11 12:00:00 AM 另外，还可以给出不正确的参数。 　　例　设定时间为1910年2月30日，它将被解释成3月2日。 　　Date day=new Date(10,1,30,10,12,34); 　　System.out.println("Day's date is:"+day); 　　//打印结果为：Day's date is:Web Mar 02 10:13:34 GMT+08:00 1910 　　下面我们给出一些Date类中常用方法。 　　(1)public static long UTC(int year,int month,int date,int hrs. int min,int sec) 　　该方法将利用给定参数计算UTC值。UTC是一种计时体制，与GMT(格林威治时间)的计 时体系略有差别。UTC计时体系是基于原子时钟的，而GTMT计时体系是基于天文学观测 的。计算中使用的一般为GMT计时体系。 　　(2)public static long parse(String s) 　　该方法将字符串s转换成一个long型的日期。在介绍构造方法Date(long date)时曾使 用过这个方法。 　　字符串s有一定的格式，一般为： 　　(星期 日 年 时间GMT+时区) 　　若不注明时区，则为本地时区。 　　(3)public void setMonth(int month) 　　(4)public int getMonth() 　　这两个方法分别为设定和获取月份值。 　　获取的月份的值域为0～11，0代表1月，11代表12月。 　　(5)public String toString() 　　(6)public String toLocalString() 　　(7)public String toGMTString() 　　将给定日期对象转换成不同格式的字符串。它们对应的具体的格式可参看例子8.1。 　　(8)public int getTimezoneOffset() 　　该方法用于获取日期对象的时区偏移量。 　　例8.1中对上面介绍的Date类中的基本方法进行了具体的应用，并打印了相应的结 果。由于使用了一些过时的方法，所以编译时会有警告信息。另外，由于本例中的时间表 示与平台有关，不同的JDK版本对此处理不完全相同，因此不同版本的JDK执行本例的结果 可能有细微差异。 　　例1.1 DateApp.java 　　import java.lang.System; 　　import java.util.Date; 　　public class DateApp{
　　　public static void main(String args[]){ 　　　　Date today=new Date(); 　　　　//today中的日期被设成创建时刻的日期和时间，假设创建时刻为1997年3月 　　　　//23日17时51分54秒。 　　　　System.out.println("Today's date is "+today); 　　　　//返回一般的时间表示法，本例中结果为 　　　　//Today's date is Fri May 23 17:51:54 1997 　　　　System.out.println("Today's date(Internet GMT)is:" 　　　　　+today.toGMTString()); 　　　　//返回结果为GMT时间表示法，本例中结果为 　　　　//Today's date(Internet GMT)is: 23 May 1997 09:51:54:GMT 　　　　System.out.println("Today's date(Locale) is:" 　　　　　+today.toLocaleString()); 　　　　//返回结果为本地习惯的时间表示法，结果为 　　　　//Today's date(Locale)is:05/23/97 17:51:54 　　　　System.out.println("Today's year is: "+today.getYear()); 　　　　System.out.println("Today's month is: "+(today.getMonth()+1)); 　　　　System.out.println("Today's date is: "+today.getDate()); 　　　　//调用Date类中方法，获取年月日的值。 　　　　//下面调用了不同的构造方法来创建Date类的对象。 　　　　Date day1=new Date(100,1,23,10,12,34); 　　　　System.out.println("Day1's date is: "+day1); 　　　　Date day2=new Date("Sat 12 Aug 1996 13:3:00"); 　　　　System.out.println("Day2's date is: "+day2); 　　　　long l= Date.parse("Sat 5 Aug 1996 13:3:00 GMT+0800"); 　　　　Date day3= new Date(l); 　　　　System.out.println("Day3's date(GMT)is: "+day3.toGMTString()); 　　　　System.out.println("Day3's date(Locale)is: " 　　　　　+day3.toLocaleString()); 　　　　System.out.println("Day3's time zone offset is:" 　　　　　+day3.getTimezoneOffset()); 　　　} 　　} 　　运行结果(JDK1.3版，与原文不同，原文是JDK1.0版)： 　　E:\java\tutorial\java01>java DateApp 　　Today's date is Thu Dec 27 17:58:16 CST 2001 　　Today's date(Internet GMT)is:27 Dec 2001 09:58:16 GMT 　　Today's date(Locale) is:2001-12-27 17:58:16 　　Today's year is: 101 　　Today's month is: 12 　　Today's date is: 27 　　Day1's date is: Wed Feb 23 10:12:34 CST 2000 　　Day2's date is: Fri Aug 12 13:03:00 CST 1996 　　Day3's date(GMT)is: 5 Aug 1996 05:03:00 GMT 　　Day3's date(Locale)is: 1996-8-5 13:03:00 　　Day3's time zone offset is:-480 　　E:\java\tutorial\java01> 1.3 日历类Calendar
　　在早期的JDK版本中，日期(Date)类附有两大功能：(1)允许用年、月、日、时、分、 秒来解释日期：(2)允许对表示日期的字符串进行格式化和句法分析。在JDK1.1中提供了 类Calendar来完成第一种功能，类DateFormat来完成第二项功能。dateFormat是 java.text包中的一个类。与Date类有所不同的是，DateFormat类接受用各种语言和不同 习惯表示的日期字符串。本节将介绍java.util包中的类Calendar及其它新增加的相关的 类。 　　类Calendar是一个抽象类，它完成日期(Date)类和普通日期表示法(即用一组整型域 如YEAR，MONTH，DAY，HOUR表示日期)之间的转换。 　　由于所使用的规则不同，不同的日历系统对同一个日期的解释有所不同。在JDK1.1中 提供了Calendar类一个子类GregorianCalendar??它实现了世界上普遍使用的公历系统。 当然用户也可以通过继承Calendar类，并增加所需规则，以实现不同的日历系统。 　　第GregorianCalendar继承了Calendar类。本节将在介绍类GregorianCalendar的同时 顺带介绍Calendar类中的相关方法。 　　类GregorianCalendar提供了七种构造函数： 　　(1)public GregorianCalendar() 　　创建的对象中的相关值被设置成指定时区，缺省地点的当前时间，即程序运行时所处 的时区、地点的当前时间。 　　(2)public GregorianCalendar(TimeZone zone) 　　创建的对象中的相关值被设置成指定时区zone，缺省地点的当前时间。 　　(3)public GregorianCalendar(Locale aLocale) 　　创建的对象中的相关值被设置成缺省时区，指定地点aLocale的当前时间。 　　(4)public GregorianCalendar(TimeZone zone,Local aLocale) 　　创建的对象中的相关值被设置成指定时区，指定地点的当前时间。 　　上面使用到的类TimeZone的性质如下： 　　TimeZone是java.util包中的一个类，其中封装了有关时区的信息。每一个时区对应 一组ID。类TimeZone提供了一些方法完成时区与对应ID两者之间的转换。 　　(Ⅰ)已知某个特定的ID，可以调用方法 　　public static synchronized TimeZone getTimeZone(String ID) 来获取对应的时区对象。 　　例 太平洋时区的ID为PST，用下面的方法可获取对应于太平洋时区的时区对象： 　　TimeZone tz=TimeZone.getTimeZone("PST"); 　　调用方法getDefault()可以获取主机所处时区的对象。 　　TimeZone tz=TimeZone.getDefault(); 　　(Ⅱ)调用以下方法可以获取时区的ID 　　■public static synchronized String[] getavailableIDs(int rawOffset) 　　根据给定时区偏移值获取ID数组。同一时区的不同地区的ID可能不同，这是由于不同 地区对是否实施夏时制意见不统一而造成的。 　　例String s[]=TimeZone.getAvailableIDs(-7*60*60*1000); 　　打印s，结果为s[0]=PNT，s[1]=MST 　　■public static synchronized String[] getAvailableIDs() 　　获取提供的所有支持的ID。 　　■public String getID() 　　获取特定时区对象的ID。 　　例 TimeZone tz=TimeZone.getDefault(); 　　String s=tz.getID(); 　　打印s，结果为s=CTT。 　　上面使用类的对象代表了一个特定的地理、政治或文化区域。Locale只是一种机制， 它用来标识一类对象，Local本身并不包含此类对象。 　　要获取一个Locale的对象有两种方法： 　　(Ⅰ)调用Locale类的构造方法
　　Locale(String language,String country) 　　Locale(String language,String country,String variant) 　　参数说明：language??在ISO-639中定义的代码，由两个小写字母组成。 　　　　　　　country??在ISO-3166中定义的代码，由两个大写字母组成。 　　　　　　　variant??售货商以及特定浏览器的代码，例如使用WIN代表Windows。 　　(Ⅱ)调用Locale类中定义的常量 　　Local类提供了大量的常量供用户创建Locale对象。 　　例 Locale.CHINA 　　　　为中国创建一个Locale的对象。 　　类TimeZone和类Locale中的其它方法，读者可查阅API。 　　(5)public GregorianCalendar(int year,int month,int date) 　　(6)public GregorianCalendar(int year,int month,int date,int hour,int minute) 　　(7)public GregorianCalendar(int year,int month,int date,int hour,int minute,int second) 　　用给定的日期和时间创建一个GregorianCalendar的对象。 　　参数说明： 　　year-设定日历对象的变量YEAR；month-设定日历对象的变量MONTH； 　　date-设定日历对象的变量DATE；hour-设定日历对象的变量HOUR_OF_DAY； 　　minute-设定日历对象的变量MINUTE；second-设定日历对象的变量SECOND。 　　与Date类中不同的是year的值没有1900这个下限，而且year的值代表实际的年 份。month的含义与Date类相同，0代表1月，11代表12月。 　　例 GregorianCalendar cal=new GregorianCalendar(1991,2,4) 　　cal的日期为1991年3月4号。 　　除了与Date中类似的方法外，Calendar类还提供了有关方法对日历进行滚动计算和数 学计算。计算规则由给定的日历系统决定。进行日期计算时，有时会遇到信息不足或信息 不实等特殊情况。Calendar采取了相应的方法解决这些问题。当信息不足时将采用缺省设 置，在GregorianCalendar类中缺省设置一般为YEAR=1970,MONTH=JANUARY,DATE=1。 　　当信息不实时，Calendar将按下面的次序优先选择相应的Calendar的变量组合，并将 其它有冲突的信息丢弃。 　　MONTH+DAY_OF_MONTH 　　MONTH+WEEK_OF_MONTH+DAY_OF_WEEK 　　MONTH+DAY_OF_WEEK_OF_MONTH+DAY_OF_WEEK 　　DAY_OF+YEAR 　　DAY_OF_WEEK_WEEK_OF_YEAR 　　HOUR_OF_DAY 1.4 随机数类Random 　　Java实用工具类库中的类java.util.Random提供了产生各种类型随机数的方法。它可 以产生int、long、float、double以及Goussian等类型的随机数。这也是它与 java.lang.Math中的方法Random()最大的不同之处，后者只产生double型的随机数。 　　类Random中的方法十分简单，它只有两个构造方法和六个普通方法。 　　构造方法： 　　(1)public Random() 　　(2)public Random(long seed) 　　Java产生随机数需要有一个基值seed，在第一种方法中基值缺省，则将系统时间作为 seed。 　　普通方法： 　　(1)public synonronized void setSeed(long seed) 　　该方法是设定基值seed。
　　(2)public int nextInt() 　　该方法是产生一个整型随机数。 　　(3)public long nextLong() 　　该方法是产生一个long型随机数。 　　(4)public float nextFloat() 　　该方法是产生一个Float型随机数。 　　(5)public double nextDouble() 　　该方法是产生一个Double型随机数。 　　(6)public synchronized double nextGoussian() 　　该方法是产生一个double型的Goussian随机数。 　　例1.2 RandomApp.java。 　　//import java.lang.*; 　　import java.util.Random; 　　public class RandomApp{ 　　　public static void main(String args[]){ 　　　　Random ran1=new Random(); 　　　　Random ran2=new Random(12345); 　　　　//创建了两个类Random的对象。 　　　　System.out.println("The 1st set of random numbers:"); 　　　　System.out.println("\t Integer:"+ran1.nextInt()); 　　　　System.out.println("\t Long:"+ran1.nextLong()); 　　　　System.out.println("\t Float:"+ran1.nextFloat()); 　　　　System.out.println("\t Double:"+ran1.nextDouble()); 　　　　System.out.println("\t Gaussian:"+ran1.nextGaussian()); 　　　　//产生各种类型的随机数 　　　　System.out.print("The 2nd set of random numbers:"); 　　　　for(int i=0;i<5;i++){ 　　　　　System.out.println(ran2.nextInt()+" "); 　　　　　if(i==2) System.out.println(); 　　　　　//产生同种类型的不同的随机数。 　　　　　System.out.println();//原文如此 　　　　} 　　　} 　　} 　　运行结果： 　　E:\java01>java RandomApp 　　The 1st set of random numbers: 　　　　Integer:-173899656 　　　　Long:8056223819738127077 　　　　Float:0.6293638 　　　　Double:0.7888394520265607 　　　　Gaussian:0.5015701094568733 　　The 2nd set of random numbers:1553932502 　　-2090749135 　　-287790814 　　-355989640 　　-716867186 　　E:\java01>
1.5 向量类Vector 　　Java.util.Vector提供了向量(Vector)类以实现类似动态数组的功能。在Java语言 中。正如在一开始就提到过，是没有指针概念的，但如果能正确灵活地使用指针又确实可 以大大提高程序的质量，比如在C、C++中所谓“动态数组”一般都由指针来实现。为了弥 补这点缺陷，Java提供了丰富的类库来方便编程者使用，Vector类便是其中之一。事实 上，灵活使用数组也可完成向量类的功能，但向量类中提供的大量方法大大方便了用户的 使用。 　　创建了一个向量类的对象后，可以往其中随意地插入不同的类的对象，既不需顾及类 型也不需预先选定向量的容量，并可方便地进行查找。对于预先不知或不愿预先定义数组 大小，并需频繁进行查找、插入和删除工作的情况，可以考虑使用向量类。 　　向量类提供了三种构造方法： 　　public vector() 　　public vector(int initialcapacity,int capacityIncrement) 　　public vector(int initialcapacity) 　　使用第一种方法，系统会自动对向量对象进行管理。若使用后两种方法，则系统将根 据参数initialcapacity设定向量对象的容量(即向量对象可存储数据的大小)，当真正存 放的数据个数超过容量时，系统会扩充向量对象的存储容量。参数capacityIncrement给 定了每次扩充的扩充值。当capacityIncrement为0时，则每次扩充一倍。利用这个功能可 以优化存储。 　　在Vector类中提供了各种方法方便用户使用： 　　■插入功能 　　(1)public final synchronized void addElement(Object obj) 　　将obj插入向量的尾部。obj可以是任何类的对象。对同一个向量对象，可在其中插入 不同类的对象。但插入的应是对象而不是数值，所以插入数值时要注意将数值转换成相应 的对象。 　　例 要插入一个整数1时，不要直接调用v1.addElement(1)，正确的方法为： 　　Vector v1=new Vector(); 　　Integer integer1=new Integer(1); 　　v1.addElement(integer1); 　　(2)public final synchronized void setElementAt(object obj,int index) 　　将index处的对象设成obj，原来的对象将被覆盖。 　　(3)public final synchronized void insertElementAt(Object obj,int index) 　　在index指定的位置插入obj，原来对象以及此后的对象依次往后顺延。 　　■删除功能 　　(1)public final synchronized void removeElement(Object obj) 　　从向量中删除obj。若有多个存在，则从向量头开始试，删除找到的第一个与obj相同 的向量成员。 　　(2)public final synchronized void removeAllElement() 　　删除向量中所有的对象。 　　(3)public final synchronized void removeElementlAt(int index) 　　删除index所指的地方的对象。 　　■查询搜索功能 　　(1)public final int indexOf(Object obj) 　　从向量头开始搜索obj ,返回所遇到的第一个obj对应的下标，若不存在此obj，返回1。 　　(2)public final synchronized int indexOf(Object obj,int index) 　　从index所表示的下标处开始搜索obj。 　　(3)public final int lastIndexOf(Object obj) 　　从向量尾部开始逆向搜索obj。 　　(4)public final synchronized int lastIndexOf(Object obj,int index)
　　从index所表示的下标处由尾至头逆向搜索obj。 　　(5)public final synchronized Object firstElement() 　　获取向量对象中的首个obj。 　　(6)public final synchronized Object lastelement() 　　获取向量对象中的最后一个obj。 　　了解了向量的最基本的方法后，我们来看一下例8.3VectorApp.java。 　　例1.3 VectorApp.java。 　　import java.util.Vector; 　　import java.lang.*;//这一句不应该要，但原文如此 　　import java.util.Enumeration; 　　public class VectorApp{ 　　　public static void main(String[] args){ 　　　　Vector v1=new Vector(); 　　　　Integer integer1=new Integer(1); 　　　　v1.addElement("one"); 　　　　//加入的为字符串对象 　　　　v1.addElement(integer1); 　　　　v1.addElement(integer1); 　　　　//加入的为Integer的对象 　　　　v1.addElement("two"); 　　　　v1.addElement(new Integer(2)); 　　　　v1.addElement(integer1); 　　　　v1.addElement(integer1); 　　　　System.out.println("The vector v1 is:\n\t"+v1); 　　　　//将v1转换成字符串并打印 　　　　v1.insertElementAt("three",2); 　　　　v1.insertElementAt(new Float(3.9),3); 　　　　System.out.println("The vector v1(used method insertElementAt()) is:\n \t "+v1); 　　　　//往指定位置插入新的对象，指定位置后的对象依次往后顺延 　　　　v1.setElementAt("four",2); 　　　　System.out.println("The vector v1(used method setElementAt()) is:\n\t "+v1); 　　　　//将指定位置的对象设置为新的对象 　　　　v1.removeElement(integer1); 　　　　//从向量对象v1中删除对象integer1由于存在多个integer1所以从头开始 　　　　//找，删除找到的第一个integer1 　　　　Enumeration enum=v1.elements(); 　　　　System.out.print("The vector v1(used method removeElement())is:"); 　　　　while(enum.hasMoreElements()) 　　　　System.out.print(enum.nextElement()+" "); 　　　　System.out.println(); 　　　　//使用枚举类(Enumeration)的方法来获取向量对象的每个元素 　　　　System.out.println("The position of object 1(top-to-bottom):" 　　　　　+ v1.indexOf(integer1)); 　　　　System.out.println("The position of object 1(tottom-to-top):" 　　　　　+v1.lastIndexOf(integer1)); 　　　　//按不同的方向查找对象integer1所处的位置 　　　　v1.setSize(4); 　　　　System.out.println("The new vector(resized the vector)is:"+v1); 　　　　//重新设置v1的大小，多余的元素被行弃
　　　} 　　} 　　运行结果： 　　E:\java01>java VectorApp 　　The vector v1 is: 　　　　　[one, 1, 1, two, 2, 1, 1] 　　The vector v1(used method insertElementAt()) is: 　　　　　[one, 1, three, 3.9, 1, two, 2, 1, 1] 　　The vector v1(used method setElementAt()) is: 　　　　　[one, 1, four, 3.9, 1, two, 2, 1, 1] 　　The vector v1(used method removeElement())is:one four 3.9 1 two 2 1 1 　　The position of object 1(top-to-bottom):3 　　The position of object 1(tottom-to-top):7 　　The new vector(resized the vector)is:[one, four, 3.9, 1] 　　E:\java01> 　　从例1.3运行的结果中可以清楚地了解上面各种方法的作用，另外还有几点需解释。 　　(1)类Vector定义了方法 　　public final int size() 　　此方法用于获取向量元素的个数。它的返回值是向是中实际存在的元素个数，而非向 量容量。可以调用方法capactly()来获取容量值。 　　方法： 　　public final synchronized void setsize(int newsize) 　　此方法用来定义向量大小。若向量对象现有成员个数已超过了newsize的值，则超过 部分的多余元素会丢失。 　　(2)程序中定义了Enumeration类的一个对象 　　Enumeration是java.util中的一个接口类，在Enumeration中封装了有关枚举数据集 合的方法。 　　在Enumeration中提供了方法hawMoreElement()来判断集合中是束还有其它元素和方 法nextElement()来获取下一个元素。利用这两个方法可以依次获得集合中元素。 　　Vector中提供方法： 　　public final synchronized Enumeration elements() 　　此方法将向量对象对应到一个枚举类型。java.util包中的其它类中也大都有这类方 法，以便于用户获取对应的枚举类型。 1.6 栈类Stack 　　Stack类是Vector类的子类。它向用户提供了堆栈这种高级的数据结构。栈的基本特 性就是先进后出。即先放入栈中的元素将后被推出。Stack类中提供了相应方法完成栈的 有关操作。 　　基本方法： 　　public Object push(Object Hem) 　　将Hem压入栈中，Hem可以是任何类的对象。 　　public Object pop() 　　弹出一个对象。 　　public Object peek() 　　返回栈顶元素，但不弹出此元素。 　　public int search(Object obj) 　　搜索对象obj,返回它所处的位置。 　　public boolean empty() 　　判别栈是否为空。 　　例1.4 StackApp.java使用了上面的各种方法。
　　例1.4 StackApp.java。 　　import java.lang.*; 　　import java.util.*; 　　public class StackApp{ 　　　public static void main(String args[]){ 　　　　Stack sta=new Stack(); 　　　　sta.push("Apple"); 　　　　sta.push("banana"); 　　　　sta.push("Cherry"); 　　　　//压入的为字符串对象 　　　　sta.push(new Integer(2)); 　　　　//压入的为Integer的对象，值为2 　　　　sta.push(new Float(3.5)); 　　　　//压入的为Float的对象，值为3.5 　　　　System.out.println("The stack is,"+sta); 　　　　//对应栈sta 　　　　System.out.println("The top of stack is:"+sta.peek()); 　　　　//对应栈顶元素，但不将此元素弹出 　　　　System.out.println("The position of object Cherry is:" 　　　　+sta.search("cherry")); 　　　　//打印对象Cherry所处的位置 　　　　System.out.print("Pop the element of the stack:"); 　　　　while(!sta.empty()) 　　　　System.out.print(sta.pop()+" "); 　　　　System.out.println(); 　　　　//将栈中的元素依次弹出并打印。与第一次打印的sta的结果比较，可看出栈 　　　　//先进后出的特点 　　　} 　　} 　　运行结果(略)
1.7 哈希表类Hashtable 　　哈希表是一种重要的存储方式，也是一种常见的检索方法。其基本思想是将关系码的 值作为自变量，通过一定的函数关系计算出对应的函数值，把这个数值解释为结点的存储 地址，将结点存入计算得到存储地址所对应的存储单元。检索时采用检索关键码的方法。 现在哈希表有一套完整的算法来进行插入、删除和解决冲突。在Java中哈希表用于存储对 象，实现快速检索。 　　Java.util.Hashtable提供了种方法让用户使用哈希表，而不需要考虑其哈希表真正 如何工作。 　　哈希表类中提供了三种构造方法，分别是： 　　public Hashtable() 　　public Hashtable(int initialcapacity) 　　public Hashtable(int initialCapacity,float loadFactor) 　　参数initialCapacity是Hashtable的初始容量，它的值应大于0。loadFactor又称装 载因子，是一个0.0到0.1之间的float型的浮点数。它是一个百分比，表明了哈希表何时 需要扩充，例如，有一哈希表，容量为100，而装载因子为0.9，那么当哈希表90%的容量 已被使用时，此哈希表会自动扩充成一个更大的哈希表。如果用户不赋这些参数，系统会 自动进行处理，而不需要用户操心。 　　Hashtable提供了基本的插入、检索等方法。
　　■插入 　　public synchronized void put(Object key,Object value) 给对象value设定一关键字key,并将其加到Hashtable中。若此关键字已经存在，则将此关 键字对应的旧对象更新为新的对象Value。这表明在哈希表中相同的关键字不可能对应不 同的对象(从哈希表的基本思想来看，这也是显而易见的)。 　　■检索 　　public synchronized Object get(Object key) 　　根据给定关键字key获取相对应的对象。 　　public synchronized boolean containsKey(Object key) 　　判断哈希表中是否包含关键字key。 　　public synchronized boolean contains(Object value) 　　判断value是否是哈希表中的一个元素。 　　■删除 　　public synchronized object remove(object key) 　　从哈希表中删除关键字key所对应的对象。 　　public synchronized void clear() 　　清除哈希表 　　另外，Hashtalbe还提供方法获取相对应的枚举集合： 　　public synchronized Enumeration keys() 　　返回关键字对应的枚举对象。 　　public synchronized Enumeration elements() 　　返回元素对应的枚举对象。 　　例1.5 Hashtable.java给出了使用Hashtable的例子。 　　例1.5 Hashtalbe.java。 　　//import java.lang.*; 　　import java.util.Hashtable; 　　import java.util.Enumeration; 　　public class HashApp{ 　　　public static void main(String args[]){ 　　　　Hashtable hash=new Hashtable(2,(float)0.8); 　　　　//创建了一个哈希表的对象hash，初始容量为2，装载因子为0.8 　　　　hash.put("Jiangsu","Nanjing"); 　　　　//将字符串对象“Jiangsu”给定一关键字“Nanjing”,并将它加入hash 　　　　hash.put("Beijing","Beijing"); 　　　　hash.put("Zhejiang","Hangzhou"); 　　　　System.out.println("The hashtable hash1 is: "+hash); 　　　　System.out.println("The size of this hash table is "+hash.size()); 　　　　//打印hash的内容和大小 　　　　Enumeration enum1=hash.elements(); 　　　　System.out.print("The element of hash is: "); 　　　　while(enum1.hasMoreElements()) 　　　　　System.out.print(enum1.nextElement()+" "); 　　　　System.out.println(); 　　　　//依次打印hash中的内容 　　　　if(hash.containsKey("Jiangsu")) 　　　　　System.out.println("The capatial of Jiangsu is "+hash.get ("Jiangsu")); 　　　　hash.remove("Beijing");
　　　　//删除关键字Beijing对应对象 　　　　System.out.println("The hashtable hash2 is: "+hash); 　　　　System.out.println("The size of this hash table is "+hash.size()); 　　　} 　　} 　　运行结果： 　　The hashtable hash1 is: {Beijing=Beijing, Zhejiang=Hangzhou, Jiangsu=Nanjing} 　　The size of this hash table is 3 　　The element of hash is: Beijing Hangzhou Nanjing 　　The capatial of Jiangsu is Nanjing 　　The hashtable hash2 is: {Zhejiang=Hangzhou, Jiangsu=Nanjing} 　　The size of this hash table is 2 　　Hashtable是Dictionary(字典)类的子类。在字典类中就把关键字对应到数据值。字 典类是一个抽象类。在java.util中还有一个类Properties，它是Hashtable的子类。用它 可以进行与对象属性相关的操作。 1.8 位集合类BitSet 　　位集合类中封装了有关一组二进制数据的操作。 　　我们先来看一下例8.6 BitSetApp.java。 　　例8.6 BitSetApp.java 　　//import java.lang.*; 　　import java.util.BitSet; 　　public class BitSetApp{ 　　　private static int n=5; 　　　public static void main(String[] args){ 　　　　BitSet set1=new BitSet(n); 　　　　for(int i=0;i<n;i++) set1.set(i); 　　　　//将set1的各位赋1，即各位均为true 　　　　BitSet set2= new BitSet(); 　　　　set2=(BitSet)set1.clone(); 　　　　//set2为set1的拷贝 　　　　set1.clear(0); 　　　　set2.clear(2); 　　　　//将set1的第0位set2的第2位清零 　　　　System.out.println("The set1 is: "+set1); 　　　　//直接将set1转换成字符串输出，输出的内容是set1中值true所处的位置 　　　　//打印结果为The set1 is:{1,2,3,4} 　　　　System.out.println("The hash code of set2 is: "+set2.hashCode()); 　　　　//打印set2的hashCode 　　　　printbit("set1",set1); 　　　　printbit("set2",set2); 　　　　//调用打印程序printbit(),打印对象中的每一个元素 　　　　//打印set1的结果为The bit set1 is: false true true true true 　　　　set1.and(set2); 　　　　printbit("set1 and set2",set1); 　　　　//完成set1 and set2,并打印结果 　　　　set1.or(set2);
　　　　printbit("set1 or set2",set1); 　　　　//完成set1 or set2,并打印结果 　　　　set1.xor(set2); 　　　　printbit("set1 xor set2",set1); 　　　　//完成set1 xor set2,并打印结果 　　　} 　　　//打印BitSet对象中的内容 　　　public static void printbit(String name,BitSet set){ 　　　　System.out.print("The bit "+name+" is: "); 　　　　for(int i=0;i<n;i++) 　　　　　System.out.print(set.get(i)+" "); 　　　　System.out.println(); 　　　} 　　} 　　运行结果： 　　The set1 is: {1, 2, 3, 4} 　　The hash code of set2 is: 1225 　　The bit set1 is: false true true true true 　　The bit set2 is: true true false true true 　　The bit set1 and set2 is: false true false true true 　　The bit set1 or set2 is: true true false true true 　　The bit set1 xor set2 is: false false false false false 　　程序中使用了BitSet类提供的两种构造方法： 　　　　public BitSet(); 　　　　public BitSet(int n); 　　参数n代表所创建的BitSet类的对象的大小。BitSet类的对象的大小在必要时会由系 统自动扩充。 　　其它方法： 　　public void set(int n) 　　将BitSet对象的第n位设置成1。 　　public void clear(int n) 　　将BitSet对象的第n位清零。 　　public boolean get(int n) 　　读取位集合对象的第n位的值，它获取的是一个布尔值。当第n位为1时，返回true； 第n位为0时，返回false。 　　另外，如在程序中所示，当把一BitSet类的对象转换成字符串输出时，输出的内容是 此对象中true所处的位置。 　　在BitSet中提供了一组位操作，分别是： 　　public void and(BitSet set) 　　public void or(BitSet set) 　　public void xor(BitSet set) 利用它们可以完成两个位集合之间的与、或、异或操作。 　　BitSet类中有一方法public int size()来取得位集合的大小，它的返回值与初始化 时设定的位集合大小n不一样，一般为64。 小结 　　本章我们介绍了Java的实用工具类库java.util中一些常用的类。java.util包中还有 其它一些类。它们的具体用法用户可以自行查阅API
本文来自CSDN博客，转载请标明出处： http://blog.csdn.net/allenjay2003/archive/2006/01/02/568705.aspx
基本概念： 1.OOP中唯一关系的是对象的接口是什么，就像计算机的销售商她不管电源内部结 构 是怎样的，他只关系能否给你提供电就行了，也就是只要知道can or not而不是how and why。所有的程序是由一定的属性和行为对象组成的，不同的对象的访问通过函数调 用来完成，对象间所有的交流都是通过方法调用，通过对封装对象数据，很大 限度上提 高复用率。
2.OOP中最重要的思想是类，类是模板是蓝图，从类中构造一个对象，即创建了这 个类的一个实例(instance)。
3.封装:就是把数据和行为结合起在一个包中)并对对象使用者隐藏数据的实现过 程，一个对象中的数据叫他的实例字段(instance field)。
4.通过扩展一个类来获得一个新类叫继承(inheritance)，而所有的类都是由 Object根超类扩展而得，根超类下文会做介绍。
5.对象的3个主要特性 ehavior---说明这个对象能做什么。 tate---当对象施加方法时对象的反映。 dentity---与其他相似行为对象的区分标志。 每个对象有唯一的indentity 而这3者之间相互影响。
6.类之间的关系: use-a :依赖关系 has-a :聚合关系
is-a :继承关系--例:A类继承了B类，此时A类不仅有了B类的方法，还有其自己的 方法.(个性存在于共性中)
7.构造对象使用构造器:构造器的提出，构造器是一种特殊的方法，构造对象并对 其初始化。 例:Data类的构造器叫Data ew Data()---构造一个新对象，且初始化当前时间。 Data happyday=new Data()---把一个对象赋值给一个变量happyday，从而使该对 象能够多次使用，此处要声明的使变量与对象变量二者是不同的.new返回的值是一个引 用。 构造器特点:构造器可以有0个，一个或多个参数； 构造器和类有相同的名字；一 个类可以有多个构造器；构造器没有返回值；构造器总是和new运算符一起使用。
8.重载:当多个方法具有相同的名字而含有不同的参数时，便发生重载.编译器必须挑选出 调用哪个方法。
9.包(package)Java允许把一个或多个类收集在一起成为一组，称作包，以便于组 织任务，标准Java库分为许多包。java.lang java.util java，net等，包是分层次的所 有的java包都在java和javax包层次内。
10.继承思想:允许在已经存在的类的基础上构建新的类，当你继承一个已经存在的 类时，那么你就复用了这个类的方法和字段，同时你可以在新类中添加新的方法和字段。
11.扩展类:扩展类充分体现了is-a的继承关系. 形式为:class (子类) extends (基类)。
12.多态:在java中，对象变量是多态的.而java中不支持多重继承。
13.动态绑定:调用对象方法的机制。 (1)编译器检查对象声明的类型和方法名。 (2)编译器检查方法调用的参数类型。 (3)静态绑定:若方法类型为priavte static final 编译器会准确知道该调用哪个
方法。 (4)当程序运行并且使用动态绑定来调用一个方法时，那么虚拟机必须调用x所指向 的对象的实际类型相匹配的方法版本。 (5)动态绑定:是很重要的特性，它能使程序变得可扩展而不需要重编译已存代码。
14.final类:为防止他人从你的类上派生新类，此类是不可扩展的。
15.动态调用比静态调用花费的时间要长。
16.抽象类:规定一个或多个抽象方法的类本身必须定义为abstract。 例: public abstract string getDescripition
17.Java中的每一个类都是从Object类扩展而来的。
18.object类中的equal和toString方法。 equal用于测试一个对象是否同另一个对象相等。 toString返回一个代表该对象的字符串，几乎每一个类都会重载该方法，以便返回 当前状态的正确表示。 (toString 方法是一个很重要的方法)
19.通用编程:任何类类型的所有值都可以同object类性的变量来代替。
20.数组列表:ArrayList动态数组列表，是一个类库，定义在java.uitl包中，可自 动调节数组的大校
21.class类 object类中的getclass方法返回ckass类型的一个实例，程序启动时包 含在main方法的类会被加载，虚拟机要加载他需要的所有类，每一个加载的类都要加载它 需要的类。
22.class类为编写可动态操纵java代码的程序提供了强大的功能反射，这项功能为 JavaBeans特别有用，使用反射Java能支持VB程序员习惯使用的工具。能够分析类能力的 程序叫反射器，Java中提供此功能的包叫Java.lang.reflect反射机制十分强大。 A.在运行时分析类的能力。 B.在运行时探察类的对象。 C.实现通用数组操纵代码。 D.提供方法对象。 而此机制主要针对是工具者而不是应用及程序。 反射机制中的最重要的部分是允许你检查类的结构.用到的API有: java.lang.reflect.Field 返回字段。 java.reflect.Method 返回方法。 java.lang.reflect.Constructor 返回参数。 方法指针:java没有方法指针，把一个方法的地址传给另一个方法，可以在后面调 用它，而接口是更好的解决方案。
23.接口(Interface)说明类该做什么而不指定如何去做，一个类可以实现一个或多 个interface。
24.接口不是一个类，而是对符合接口要求的类的一套规范。若实现一个接口需要2 个步骤: A.声明类需要实现的指定接口。 B.提供接口中的所有方法的定义。 声明一个类实现一个接口需要使用implements 关键字class actionB implements Comparable 其actionb需要提供CompareTo方法，接口不是类，不能用new实例化一个接 口。
25.一个类只有一个超类，但一个类能实现多个接口。Java中的一个重要接口： Cloneable
26.接口和回调.编程一个常用的模式是回调模式，在这种模式中你可以指定当一个 特定时间发生时回调对象上的方法。
例:ActionListener 接口监听。 类似的API有: java.swing.JOptionPane java.swing.Timer java.awt.Tookit
27.对象clone:clone方法是object一个保护方法，这意味着你的代码不能简单的调 用它。
28.内部类:一个内部类的定义是定义在另一个内部的类。原因是: A.一个内部类的对象能够访问创建它的对象的实现，包括私有数据。 B.对于同一个包中的其他类来说，内部类能够隐藏起来。 C.匿名内部类可以很方便的定义回调。 D.使用内部类可以非常方便的编写事件驱动程序。
29.代理类(proxy): A.指定接口要求所有代码 B.object类定义的所有的方法(toString equals)
30.数据类型:Java是强调类型的语言，每个变量都必须先申明它都类型，java中总 共有8个基本类型.4种是整型，2种是浮点型，一种是字符型，被用于Unicode编码中的字 符，布尔型。
