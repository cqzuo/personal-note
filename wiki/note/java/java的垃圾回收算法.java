Java的垃圾回收算法

Java ，C#语言与C/C++语言一个很大的区别是java与C#具有自动垃圾回收机制。C++程序员经常需要绞尽脑汁的分析哪里出现了内存泄漏。而在java，C#中，虽然有时也会出现内存泄漏，但大部分情况下程序员不需要考虑对象或者数据何时需要被销毁。因此程序员不会因为错误的释放内存而导致程序崩溃。垃圾回收的缺点是加大了程序的负担，有可能影响程序的性能。

1．垃圾收集器的主要功能有

（1）       定期发现那些对象不再被引用，并把这些对象占据的堆空间释放出来。

（2）       类似于操作系统的内存管理，垃圾收集器还需要处理由于对象动态生成与销毁产生的堆碎块，以便更有效的利用虚拟机内存。

     2．区分活动对象与垃圾的算法

         （1）引用计数法

        堆中每一个对象都有一个引用计数。当新创建一个对象，或者有变量被赋值为这个对象的引用，则这个对象的引用计数加1；当一个对象的引用超过生存期或者被设置一个新的值时，这个对象的引用计数减1。当对象的引用计数变为0时，就可以被当作垃圾收集。

           这种方法的好处是垃圾收集较快，适用于实时环境。缺点是这种方法无法监测出循环引用。例如对象A引用对象B，对象B也引用对象A，则这两个对象可能无法被垃圾收集器收集。因此这种方法是垃圾收集的早期策略，现在很少使用。

           

（2）跟踪法

     这种方法把每个对象看作图中一个节点，对象之间的引用关系为图中各节点的邻接关系。垃圾收集器从一个或数个根结点遍历对象图，如果有些对象节点永远无法到达，则这个对象可以被当作垃圾回收。

     容易发现，这种方法可以检测出循环引用，避免了引用计数法的缺点，较为常用。

<o:p> </o:p>

3．常用垃圾回收机制

 （1）标记－清除收集器

　　这种收集器首先遍历对象图并标记可到达的对象，然后扫描堆栈以寻找未标记对象并释放它们的内存。这种收集器一般使用单线程工作并停止其他操作。

（2）标记－压缩收集器

　　有时也叫标记－清除－压缩收集器，与标记－清除收集器有相同的标记阶段。在第二阶段，则把标记对象复制到堆栈的新域中以便压缩堆栈。这种收集器也停止其他操作。

（3）复制收集器

这 种收集器将堆栈分为两个域，常称为半空间。每次仅使用一半的空间，虚拟机生成的新对象则放在另一半空间中。垃圾回收器运行时，它把可到达对象复制到另一半 空间，没有被复制的的对象都是不可达对象，可以被回收。这种方法适用于短生存期的对象，持续复制长生存期的对象由于多次拷贝，导致效率降低。缺点是只有一 半的虚拟机空间得到使用。

（4）增量收集器

增量收集器把堆栈分为多个域，每次仅从一个域收集垃圾。这会造成较小的应用程序中断。

（5）分代收集器

这种收集器把堆栈分为两个或多个域，用以存放不同寿命的对象。虚拟机生成的新对象一般放在其中的某个域中。过一段时间，继续存在的对象将获得使用期并转入更长寿命的域中。分代收集器对不同的域使用不同的算法以优化性能。这样可以减少复制对象的时间。

（6）并发收集器

并发收集器与应用程序同时运行。这些收集器在某点上（比如压缩时）一般都不得不停止其他操作以完成特定的任务，但是因为其他应用程序可进行其他的后台操作，所以中断其他处理的实际时间大大降低。

（7）并行收集器

并行收集器使用某种传统的算法并使用多线程并行的执行它们的工作。在多CPU机器上使用多线程技术可以显著的提高java应用程序的可扩展性。

         （8）自适应收集器

         根据程序运行状况以及堆的使用状况，自动选一种合适的垃圾回收算法。这样可以不局限与一种垃圾回收算法。

<o:p> </o:p>

         4． 火车算法<o:p></o:p>

              垃圾收集算法一个很大的缺点就是难以控制垃圾回收所占用的CPU时间，以及何时需要进行垃圾回收。火车算法是分代收集器所用的算法，目的是在成熟对象空间中提供限定时间的渐进收集。目前应用于SUN公司的Hotspot虚拟机上。

              在火车算法中，内存被分为块，多个块组成一个集合。为了形象化，一节车厢代表一个块，一列火车代表一个集合，见图一

   

图一
注意每个车厢大小相等，但每个火车包含的车厢数不一定相等。垃圾收集以车厢为单位，收集顺序依次为1.1，1.2，1.3，1.4，2.1，2.2，2.3，3.1，3.2，3.3。这个顺序也是块被创建的先后顺序。
垃圾收集器先从块1.1开始扫描直到1.4，如果火车1四个块中的所有对象没有被火车2和火车3的对象引用，而只有火车1内部的对象相互引用，则整个火车1都是垃圾，可以被回收。
如图二，车厢1.1中有对象A和对象B，1.3中有对象C，1.4中有对象D，车厢2.2中有对象E，车厢3.3中有对象F。在火车1中，对象C引用对象A，对象B引用对象D，可见，火车2和火车3没有引用火车1的对象，则整个火车1都是垃圾。

 

                                                  图2
如果火车1中有对象被其它火车引用，见图三，扫描车厢1.1时发现对象A被火车2中的E引用，则将对象A从车厢1.1转移到车厢2.2，然后扫描A引用的对象D，把D也转移到车厢2.2，然后扫描D，看D是否引用其它对象，如果引用了其它对象则也要转移，依次类推。扫描完火车1的所有对象后，剩下的没有转移的对象都是垃圾，可以把整个火车1都作为垃圾回收。注意如果在转移时，如果车厢2.2空间满了，则要在火车2末尾开辟新的车厢2.4，将新转移的对象都放到2.4，即火车的尾部）



                                         图3

补充说明：垃圾回收器一次只扫描一个车厢。图三中的对象B与C并不是立即被回收，而是先会被转移到火车1的尾部车厢。即扫描完1.1后，B被转移到火车1尾部，扫描完1.3后，C被转移到车尾。等垃圾收集器扫描到火车1尾部时，如果仍然没有外部对象引用它们，则B和C会被收集。

     火车算法最大的好处是它可以保证大的循环结构可以被完全收集，因为成为垃圾的循环结构中的对象，无论多大，都会被移入同一列火车，最终一起被收集。还有一个好处是这种算法在大多数情况下可以保证一次垃圾收集所耗时间在一定限度之内，因为一次垃圾回收只收集一个车厢，而车厢的大小是有限度的。