<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=gbk" /> 
        <title>ssh面试题</title>
        <meta id="viewport" name="viewport" 
            content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;" /> 
        <link rel="stylesheet" href="style.css" /> 
        <link rel="apple-touch-icon" href="../images/apple-touch-icon.png" /> 
		<link type="text/css" rel="stylesheet" href="../SyntaxHighlighter/Styles/SyntaxHighlighter.css"></link> 
		<script class="javascript" src="../SyntaxHighlighter/Scripts/shCore.js"></script> 
		<script class="javascript" src="../SyntaxHighlighter/Scripts/shBrushCSharp.js"></script> 
		<script class="javascript" src="../SyntaxHighlighter/Scripts/shBrvushPhp.js"></script> 
		<script class="javascript" src="../SyntaxHighlighter/Scripts/shBrushJScript.js"></script> 
		<script class="javascript" src="../SyntaxHighlighter/Scripts/shBrushJava.js"></script> 
		<script class="javascript" src="../SyntaxHighlighter/Scripts/shBrushVb.js"></script> 
		<script class="javascript" src="../SyntaxHighlighter/Scripts/shBrushSql.js"></script> 
		<script class="javascript" src="../SyntaxHighlighter/Scripts/shBrushXml.js"></script> 
		<script class="javascript" src="../SyntaxHighlighter/Scripts/shBrushDelphi.js"></script> 
		<script class="javascript" src="../SyntaxHighlighter/Scripts/shBrushPython.js"></script> 
		<script class="javascript" src="../SyntaxHighlighter/Scripts/shBrushRuby.js"></script> 
		<script class="javascript" src="../SyntaxHighlighter/Scripts/shBrushCss.js"></script> 
		<script class="javascript" src="../SyntaxHighlighter/Scripts/shBrushCpp.js"></script> 
		
		<link type="text/css" rel="stylesheet" href="../SyntaxHighlighter/styles/shCoreDefault.css"/> 
		<script type="text/javascript">SyntaxHighlighter.all();</script> 

		<script type="text/javascript" charset="utf-8"> 
            window.onload = function() {
                var header = document.getElementById('header').getElementsByTagName('h1')[0],
                    old = document.getElementById('content').getElementsByTagName('h1')[0];
                if (old) header.innerHTML = old.innerHTML;
                setTimeout(function(){
                    window.scrollTo(0, 1);
                }, 100);
            }
        </script>
    </head>
    <body>
        <div id="header">
            <a href="index.html" id="backButton">Index</a><!--<center><h1>ssh面试题</h1></center> -->
        </div>
        <div id="content">
<div class="toc">
<ul>
<li><a href="#toc_0.1">Hibernate</a></li>
<ul>
<li><a href="#toc_0.1.1">原理</a></li>
<li><a href="#toc_0.1.2">为什么要用</a></li>
<li><a href="#toc_0.1.3">hibernate是如何延迟加载</a></li>
<li><a href="#toc_0.1.4">Hibernate中怎样实现类之间的关系</a></li>
<li><a href="#toc_0.1.5">说下Hibernate的缓存机制</a></li>
<li><a href="#toc_0.1.6">hibernate的查询方式</a></li>
<li><a href="#toc_0.1.7">如何优化Hibernate</a></li>
</ul>
<li><a href="#toc_0.2">Struts1</a></li>
<ul>
<li><a href="#toc_0.2.1">工作机制</a></li>
<li><a href="#toc_0.2.2">为什么要用</a></li>
<li><a href="#toc_0.2.3">Struts的validate框架是如何验证的？</a></li>
<li><a href="#toc_0.2.4">说下Struts的设计模式</a></li>
</ul>
<li><a href="#toc_0.3">spring</a></li>
<ul>
<li><a href="#toc_0.3.1">spring工作机制</a></li>
<li><a href="#toc_0.3.2">为什么用</a></li>
</ul>
<li><a href="#toc_0.4">用自己的话简要阐述struts2的执行流程。</a></li>
</ul>
</ul>
</div>
<h2 id="toc_0.1">Hibernate</h2>
<h3 id="toc_0.1.1">原理</h3>
<ol>
<li>
读取并解析配置文件
</li>
<li>
读取并解析映射信息，创建sessionFactory
</li>
<li>
打开Sesssion
</li>
<li>
创建事务Transation
</li>
<li>
持久化操作
</li>
<li>
提交事务
</li>
<li>
关闭Session
</li>
<li>
关闭sesstionFactory
</li>
</ol>
<h3 id="toc_0.1.2">为什么要用</h3>
<ol>
<li>
对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。
</li>
<li>
Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作
</li>
<li>
hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。
</li>
<li>
hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。
</li>
</ol>
<h3 id="toc_0.1.3"><a href="hibernate是如何延迟加载.html">hibernate是如何延迟加载</a></h3>
<ol>
<li>
Hibernate2延迟加载实现：a)实体对象 b)集合（Collection）
</li>
<li>
Hibernate3 提供了属性的延迟加载功能
</li>
<li>
当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。
</li>
</ol>
<h3 id="toc_0.1.4">Hibernate中怎样实现类之间的关系</h3>
<p>
 类与类之间的关系主要体现在表与表之间的关系进行操作，它们都是对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many、
<h3 id="toc_0.1.5">说下<a href="Hibernate的缓存机制.html">Hibernate的缓存机制</a></h3>
</p>
<ol>
<li>
内部缓存存在Hibernate中又叫一级缓存，属于应用事务级缓存
</li>
<li>
二级缓存：
</li>
<ul>
<li>
应用及缓存
</li>
<li>
分布式缓存
</li>
<ul>
<li>
条件：数据不会被第三方修改、数据大小在可接受范围、数据更新频率低、同一数据被系统频繁使用、非 关键数据
</li>
</ul>
<li>
第三方缓存的实现
</li>
</ul>
</ol>
<h3 id="toc_0.1.6"><a href="hibernate的查询方式.html">hibernate的查询方式</a></h3>
<ul>
<li>
Sql、Criteria,object comptosition Hql：
</li>
<li>
属性查询
</li>
<li>
参数查询、命名参数查询
</li>
<li>
关联查询
</li>
<li>
分页查询
</li>
<li>
统计函数
</li>
</ul>
<h3 id="toc_0.1.7">如何优化Hibernate</h3>
<ol>
<li>
使用双向一对多关联，不使用单向一对多
</li>
<li>
灵活使用单向一对多关联
</li>
<li>
不用一对一，用多对一取代
</li>
<li>
配置对象缓存，不使用集合缓存
</li>
<li>
一对多集合使用Bag,多对多集合使用Set
</li>
<li>
继承类使用显式多态
</li>
<li>
表字段要少，表关联不要怕多，有二级缓存撑腰
</li>
</ol>
<h2 id="toc_0.2">Struts1</h2>
<h3 id="toc_0.2.1">工作机制</h3>
<ul>
<li>
在web应用启动时就会加载初始化actionServlet,actionServlet从struts-config.xml文件中读取配置信息,把它们存放到各种配置对象
</li>
<li>
当actionServlet接收到一个客户请求时,将执行如下流程
</li>
<ol>
<li>
检索和用户请求匹配的actionMapping实例,如果不存在,就返回请求路径无效信息; 
</li>
<li>
如果actionForm实例不存在,就创建一个actionForm对象,把客户提交的表单数据保存到actionForm对象中; 
</li>
<li>
根据配置信息决定是否需要表单验证.如果需要验证,就调用actionForm的validate()方法; 
</li>
<li>
如果actionForm的validate()方法返回null或返回一个不包含actionMessage的actuibErrors对象, 就表示表单验证成功; 
</li>
<li>
actionServlet根据actionMapping所包含的映射信息决定将请求转发给哪个Action,如果相应的 Action实例不存在,就先创建这个实例,然后调用Action的execute()方法; 
</li>
<li>
Action的execute()方法返回一个actionForward对象,actionServlet在把客户请求转发给 actionForward对象指向的JSP组件; 
</li>
<li>
actionForward对象指向JSP组件生成动态网页,返回给客户; 
</li>
</ol>
</ul>
<h3 id="toc_0.2.2">为什么要用</h3>
<ul>
<li>
JSP、Servlet、<a href="JavaBean.html">JavaBean</a>技术的出现给我们构建强大的企业应用系统提供了可能。但用这些技术构建的系统非常的繁乱，所以在此之上，我们需要一个规则、一个把这些技术组织起来的规则，这就是框架，Struts便应运而生。
</li>
<li>
基于Struts开发的应用由3类组件构成：控制器组件、模型组件、视图组件
</li>
</ul>
<h3 id="toc_0.2.3">Struts的validate框架是如何验证的？</h3>
<p>
 在struts配置文件中配置具体的错误提示，再在formBean中的validate()方法具体调用。
<h3 id="toc_0.2.4">说下Struts的设计模式</h3>
 MVC模式: web应用程序启动时就会加载并初始化actionServlert。用户提交表单时，一个配置好的actionForm对象被创建，并被填入表单相应的数据，<a href="ActionServler.html">ActionServler</a>根据Struts-config.xml文件配置好的设置决定是否需要表单验证，如果需要就调用actionForm的 Validate（）验证后选择将请求发送到哪个Action，如果Action不存在，actionServlet会先创建这个对象，然后调用 Action的execute（）方法。Execute（）从actionForm对象中获取数据，完成业务逻辑，返回一个actionForward对象，actionServlet再把客户请求转发给actionForward对象指定的jsp组件，actionForward对象指定的jsp生成动态的网页，返回给客户。
<h2 id="toc_0.3">spring</h2>
<h3 id="toc_0.3.1">spring工作机制</h3>
</p>
<ol>
<li>
spring mvc请所有的请求都提交给<a href="DispatcherServlet.html">DispatcherServlet</a>,它会委托应用系统的其他模块负责负责对请求进行真正的处理工作。
</li>
<li>
<a href="DispatcherServlet.html">DispatcherServlet</a>查询一个或多个<a href="HandlerMapping.html">HandlerMapping</a>,找到处理请求的Controller
</li>
<li>
<a href="DispatcherServlet.html">DispatcherServlet</a>请请求提交到目标Controller
</li>
<li>
Controller进行业务逻辑处理后，会返回一个<a href="ModelAndView.html">ModelAndView</a>
</li>
<li>
Dispathcher查询一个或多个<a href="ViewResolver.html">ViewResolver</a>视图解析器,找到<a href="ModelAndView.html">ModelAndView</a>对象指定的视图对象
</li>
<li>
视图对象负责渲染返回给客户端。
</li>
</ol>
<h3 id="toc_0.3.2">为什么用</h3>
<p>
 AOP 让开发人员可以创建非行为性的关注点，称为横切关注点，并将它们插入到应用程序代码中。使用 AOP 后，公共服务 （比如日志、持久性、事务等）就可以分解成方面并应用到域对象上，同时不会增加域对象的对象模型的复杂性。
 IOC 允许创建一个可以构造对象的应用环境，然后向这些对象传递它们的协作对象。正如单词 倒置 所表明的，IOC 就像反 过来的 JNDI。没有使用一堆抽象工厂、服务定位器、单元素（singleton）和直接构造（straight construction），每一个对象都是用其协作对象构造的。因此是由容器管理协作对象（collaborator）。
 Spring即使一个AOP框架，也是一IOC容器。 Spring 最好的地方是它有助于您替换对象。有了 Spring，只要用 <a href="JavaBean.html">JavaBean</a> 属性和配置文件加入依赖性（协作对象）。然后可以很容易地在需要时替换具有类似接口的协作对象
Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式
组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：
☆ 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 <a href="BeanFactory.html">BeanFactory</a>，它是工厂模式的实现。<a href="BeanFactory.html">BeanFactory</a> 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。
☆ Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。
☆ Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。
☆ Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。
☆ Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。
☆ Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。
☆ Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。
Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。
IOC 和 AOP
控制反转模式（也称作依赖性介入）的基本概念是：不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。容器（在 Spring 框架中是 IOC 容器） 负责将这些联系在一起。
在典型的 IOC 场景中，容器创建了所有对象，并设置必要的属性将它们连接在一起，决定什么时间调用方法。下表列出了 IOC 的一个实现模式。
</p>
 
<p>
Spring 框架的 IOC 容器采用类型 2 和类型3 实现。
面向方面的编程
面向方面的编程，即 AOP，是一种编程技术，它允许程序员对横切关注点或横切典型的职责分界线的行为（例如日志和事务管理）进行模块化。AOP 的核心构造是方面，它将那些影响多个类的行为封装到可重用的模块中。
AOP 和 IOC 是补充性的技术，它们都运用模块化方式解决企业应用程序开发中的复杂问题。在典型的面向对象开发方式中，可能要将日志记录语句放在所有方法和 Java 类中才能实现日志功能。在 AOP 方式中，可以反过来将日志服务模块化，并以声明的方式将它们应用到需要日志的组件上。当然，优势就是 Java 类不需要知道日志服务的存在，也不需要考虑相关的代码。所以，用 Spring AOP 编写的应用程序代码是松散耦合的。
AOP 的功能完全集成到了 Spring 事务管理、日志和其他各种特性的上下文中。
IOC 容器
Spring 设计的核心是 org.springframework.beans 包，它的设计目标是与 <a href="JavaBean.html">JavaBean</a> 组件一起使用。这个包通常不是由用户直接使用，而是由服务器将其用作其他多数功能的底层中介。下一个最高级抽象是 <a href="BeanFactory.html">BeanFactory</a> 接口，它是工厂设计模式的实现，允许通过名称创建和检索对象。<a href="BeanFactory.html">BeanFactory</a> 也可以管理对象之间的关系。
<a href="BeanFactory.html">BeanFactory</a> 支持两个对象模型。
□ 单态 模型提供了具有特定名称的对象的共享实例，可以在查询时对其进行检索。Singleton 是默认的也是最常用的对象模型。对于无状态服务对象很理想。
□ 原型 模型确保每次检索都会创建单独的对象。在每个用户都需要自己的对象时，原型模型最适合。
bean 工厂的概念是 Spring 作为 IOC 容器的基础。IOC 将处理事情的责任从应用程序代码转移到框架。正如我将在下一个示例中演示的那样，Spring 框架使用 <a href="JavaBean.html">JavaBean</a> 属性和配置数据来指出必须设置的依赖关系。
<a href="BeanFactory.html">BeanFactory</a> 接口
因为 org.springframework.beans.factory.<a href="BeanFactory.html">BeanFactory</a> 是一个简单接口，所以可以针对各种底层存储方法实现。最常用的 <a href="BeanFactory.html">BeanFactory</a> 定义是 <a href="XmlBeanFactory.html">XmlBeanFactory</a>，它根据 XML 文件中的定义装入 bean，如清单 1 所示。
清单 1. <a href="XmlBeanFactory.html">XmlBeanFactory</a>
<a href="BeanFactory.html">BeanFactory</a> factory = new <a href="XMLBeanFactory.html">XMLBeanFactory</a>(new <a href="FileInputSteam.html">FileInputSteam</a>("mybean.xml")); 
在 XML 文件中定义的 Bean 是被消极加载的，这意味在需要 bean 之前，bean 本身不会被初始化。要从 <a href="BeanFactory.html">BeanFactory</a> 检索 bean，只需调用 getBean() 方法，传入将要检索的 bean 的名称即可，如清单 2 所示。
清单 2. getBean()
<a href="MyBean.html">MyBean</a> mybean = (<a href="MyBean.html">MyBean</a>) factory.getBean("mybean"); 
每个 bean 的定义都可以是 POJO （用类名和 <a href="JavaBean.html">JavaBean</a> 初始化属性定义） 或 <a href="FactoryBean.html">FactoryBean</a>。<a href="FactoryBean.html">FactoryBean</a> 接口为使用 Spring 框架构建的应用程序添加了一个间接的级别。
IOC 示例
理解控制反转最简单的方式就是看它的实际应用。在对由三部分组成的 Spring 系列 的第 1 部分进行总结时，我使用了一个示例，演示了如何通过 Spring IOC 容器注入应用程序的依赖关系（而不是将它们构建进来）。
我用开启在线信用帐户的用例作为起点。对于该实现，开启信用帐户要求用户与以下服务进行交互：
☆ 信用级别评定服务，查询用户的信用历史信息。
☆ 远程信息链接服务，插入客户信息，将客户信息与信用卡和银行信息连接起来，以进行自动借记（如果需要的话）。
☆ 电子邮件服务，向用户发送有关信用卡状态的电子邮件。
三个接口
对于这个示例，我假设服务已经存在，理想的情况是用松散耦合的方式把它们集成在一起。以下清单显示了三个服务的应用程序接口。
清单 3. <a href="CreditRatingInterface.html">CreditRatingInterface</a>
public interface <a href="CreditRatingInterface.html">CreditRatingInterface</a> {
public boolean getUserCreditHistoryInformation(ICustomer iCustomer); 
}
清单 3 所示的信用级别评定接口提供了信用历史信息。它需要一个包含客户信息的 Customer 对象。该接口的实现是由 <a href="CreditRating.html">CreditRating</a> 类提供的。
清单 4. <a href="CreditLinkingInterface.html">CreditLinkingInterface</a>
public interface <a href="CreditLinkingInterface.html">CreditLinkingInterface</a> {
public String getUrl(); 
public void setUrl(String url); 
public void linkCreditBankAccount() throws Exception ; 
}
信用链接接口将信用历史信息与银行信息（如果需要的话）连接在一起，并插入用户的信用卡信息。信用链接接口是一个远程服务，它的查询是通过 getUrl() 方法进行的。URL 由 Spring 框架的 bean 配置机制设置，我稍后会讨论它。该接口的实现是由 <a href="CreditLinking.html">CreditLinking</a> 类提供的。
清单 5. <a href="EmailInterface.html">EmailInterface</a>
public interface <a href="EmailInterface.html">EmailInterface</a> {
public void sendEmail(ICustomer iCustomer); 
public String getFromEmail(); 
public void setFromEmail(String fromEmail) ; 
public String getPassword(); 
public void setPassword(String password) ; 
public String getSmtpHost() ; 
public void setSmtpHost(String smtpHost); 
public String getUserId() ; 
public void setUserId(String userId);
<h2 id="toc_0.4">用自己的话简要阐述struts2的执行流程。</h2>
</p>
<ul>
<li>
Struts 2框架本身大致可以分为3个部分：核心控制器<a href="FilterDispatcher.html">FilterDispatcher</a>、业务控制器Action和用户实现的企业业务逻辑组件。
</li>
<li>
核心控制器<a href="FilterDispatcher.html">FilterDispatcher</a>是Struts 2框架的基础，包含了框架内部的控制流程和处理机制。
</li>
<li>
业务控制器Action和业务逻辑组件是需要用户来自己实现的。用户在开发Action和业务逻辑组件的同时，还需要编写相关的配置文件，供核心控制器<a href="FilterDispatcher.html">FilterDispatcher</a>来使用。 S
</li>
<li>
truts 2的工作流程相对于Struts 1要简单，与<a href="WebWork.html">WebWork</a>框架基本相同，所以说Struts 2是<a href="WebWork.html">WebWork</a>的升级版本。基本简要流程如下：
</li>
<ol>
<li>
客户端浏览器发出HTTP请求。
</li>
<li>
根据web.xml配置，该请求被<a href="FilterDispatcher.html">FilterDispatcher</a>接收。
</li>
<li>
根据struts.xml配置，找到需要调用的Action类和方法， 并通过<a href="IoC.html">IoC</a>方式，将值注入给Aciton。
</li>
<li>
Action调用业务逻辑组件处理业务逻辑，这一步包含表单验证。
</li>
<li>
Action执行完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应页面。
</li>
<li>
返回HTTP响应到客户端浏览器。
</li>
</ol>
</ul>
<li>
一个请求在Struts2框架中的处理大概分为以下几个步骤 
</li>
<ol>
<li>
客户端初始化一个指向Servlet容器（例如Tomcat）的请求 
</li>
<li>
这个请求经过一系列的过滤器（Filter）（这些过滤器中有一个叫做<a href="ActionContextCleanUp.html">ActionContextCleanUp</a>的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：<a href="SiteMesh.html">SiteMesh</a> Plugin） 
</li>
<li>
接着<a href="FilterDispatcher.html">FilterDispatcher</a>被调用，<a href="FilterDispatcher.html">FilterDispatcher</a>询问<a href="ActionMapper.html">ActionMapper</a>来决定这个请是否需要调用某个Action 
</li>
<li>
如果<a href="ActionMapper.html">ActionMapper</a>决定需要调用某个Action，<a href="FilterDispatcher.html">FilterDispatcher</a>把请求的处理交给<a href="ActionProxy.html">ActionProxy</a> 
</li>
<li>
<a href="ActionProxy.html">ActionProxy</a>通过Configuration Manager询问框架的配置文件，找到需要调用的Action类 
</li>
<li>
<a href="ActionProxy.html">ActionProxy</a>创建一个<a href="ActionInvocation.html">ActionInvocation</a>的实例。 
</li>
<li>
<a href="ActionInvocation.html">ActionInvocation</a>实例使用命名模式来调用，在调用Action的过程前后，涉及到相关拦截器（Intercepter）的调用。 
</li>
<li>
一旦Action执行完毕，<a href="ActionInvocation.html">ActionInvocation</a>负责根据struts.xml中的配置找到对应的返回结果。返回结果通常是（但不总是，也可 能是另外的一个Action链）一个需要被表示的JSP或者<a href="FreeMarker.html">FreeMarker</a>的模版。在表示的过程中可以使用Struts2 框架中继承的标签。在这个过程中需要涉及到<a href="ActionMapper.html">ActionMapper</a> 
</li>
</ol>
<li>
在上述过程中所有的对象（Action，Results，Interceptors，等）都是通过<a href="ObjectFactory.html">ObjectFactory</a>来创建的。
</li>
<p>
一、spring工作原理：
1.spring mvc请所有的请求都提交给<a href="DispatcherServlet.html">DispatcherServlet</a>,它会委托应用系统的其他模块负责负责对请求进行真正的处理工作。
2.<a href="DispatcherServlet.html">DispatcherServlet</a>查询一个或多个<a href="HandlerMapping.html">HandlerMapping</a>,找到处理请求的Controller. 
3.<a href="DispatcherServlet.html">DispatcherServlet</a>请请求提交到目标Controller 
4.Controller进行业务逻辑处理后，会返回一个<a href="ModelAndView.html">ModelAndView</a> 
5.Dispathcher查询一个或多个<a href="ViewResolver.html">ViewResolver</a>视图解析器,找到<a href="ModelAndView.html">ModelAndView</a>对象指定的视图对象 
6.视图对象负责渲染返回给客户端。 
</p>
 
<p>
二、为什么要用spring:
AOP 让开发人员可以创建非行为性的关注点，称为横切关注点，并将它们插入到应用程序代码中。使用 AOP 后，公共服务   （比 如日志、持久性、事务等）就可以分解成方面并应用到域对象上，同时不会增加域对象的对象模型的复杂性。 
IOC 允许创建一个可以构造对象的应用环境，然后向这些对象传递它们的协作对象。正如单词 倒置 所表明的，IOC 就像反      过来的 JNDI。没有使用一堆抽象工厂、服务定位器、单元素（singleton）和直接构造（straight construction），每一个对象都是用     其协作对象构造的。因此是由容器管理协作对象（collaborator）。 
Spring即使一个AOP框架，也是一IOC容器。 Spring 最好的地方是它有助于您替换对象。有了 Spring，只要用 <a href="JavaBean.html">JavaBean</a> 属性和配置文件加入依赖性（协作对象）。然后可以很容易地在需要时替换具有类似接口的协作对象。 
三、请你谈谈SSH整合：
SSH：
Struts（表示层）+Spring（业务层）+Hibernate（持久层）
Struts：
Struts是一个表示层框架，主要作用是界面展示，接收请求，分发请求。
在MVC框架中，Struts属于VC层次，负责界面表现，负责MVC关系的分发。（View：沿用JSP，HTTP，Form，Tag，Resourse ；Controller：actionServlet，struts-config.xml，Action）
Hibernate：
Hibernate是一个持久层框架，它只负责与关系数据库的操作。
Spring：
Spring是一个业务层框架，是一个整合的框架，能够很好地黏合表示层与持久层。
四、介绍一下Spring的事务管理： 
事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。
这样可以防止出现脏数据，防止数据库数据出现问题。
开发中为了避免这种情况一般都会进行事务管理。Spring中也有自己的事务管理机制，一般是使用<a href="TransactionMananger.html">TransactionMananger</a>进行管理，可以通过Spring的注入来完成此功能。
spring提供了几个关于事务处理的类：
<a href="TransactionDefinition.html">TransactionDefinition</a> //事务属性定义
<a href="TranscationStatus.html">TranscationStatus</a> //代表了当前的事务，可以提交，回滚。
<a href="PlatformTransactionManager.html">PlatformTransactionManager</a>这个是spring提供的用于管理事务的基础接口，其下有一个实现的抽象类<a href="AbstractPlatformTransactionManager.html">AbstractPlatformTransactionManager</a>,我们使用的事务管理类例如<a href="DataSourceTransactionManager.html">DataSourceTransactionManager</a>等都是这个类的子类。
一般事务定义步骤：
<a href="TransactionDefinition.html">TransactionDefinition</a> td = new <a href="TransactionDefinition.html">TransactionDefinition</a>();
<a href="TransactionStatus.html">TransactionStatus</a> ts = transactionManager.getTransaction(td);
try
{ //do sth
transactionManager.commit(ts);
}
catch(Exception e){transactionManager.rollback(ts);}
spring提供的事务管理可以分为两类：编程式的和声明式的。编程式的，比较灵活，但是代码量大，存在重复的代码比较多；声明式的比编程式的更灵活。
编程式主要使用transactionTemplate。省略了部分的提交，回滚，一系列的事务对象定义，需注入事务管理对象.
void add(){
transactionTemplate.execute( new <a href="TransactionCallback.html">TransactionCallback</a>(){
pulic Object doInTransaction(<a href="TransactionStatus.html">TransactionStatus</a> ts)
{ //do sth}
}
}
声明式：
使用<a href="TransactionProxyFactoryBean.html">TransactionProxyFactoryBean</a>:
PROPAGATION_REQUIRED PROPAGATION_REQUIRED PROPAGATION_REQUIRED,readOnly 
</p>
 
<p>
围绕Poxy的动态代理 能够自动的提交和回滚事务
org.springframework.transaction.interceptor.<a href="TransactionProxyFactoryBean.html">TransactionProxyFactoryBean</a>
PROPAGATION_REQUIREDC支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。
PROPAGATION_SUPPORTSC支持当前事务，如果当前没有事务，就以非事务方式执行。
PROPAGATION_MANDATORYC支持当前事务，如果当前没有事务，就抛出异常。
PROPAGATION_REQUIRES_NEWC新建事务，如果当前存在事务，把当前事务挂起。
PROPAGATION_NOT_SUPPORTEDC以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
PROPAGATION_NEVERC以非事务方式执行，如果当前存在事务，则抛出异常。
PROPAGATION_NESTEDC如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。
五、Spring里面如何配置数据库驱动？
使用”org.springframework.jdbc.datasource.<a href="DriverManagerDataSource.html">DriverManagerDataSource</a>”数据源来配置数据库驱动。示例如下：
&lt;bean id=”dataSource”&gt;
</p>
<blockquote>
&lt;property name=”driverClassName”&gt;
&lt;value&gt;org.hsqldb.jdbcDriver&lt;/value&gt;
&lt;/property&gt;
&lt;property name=”url”&gt;
&lt;value&gt;jdbc:hsqldb:db/appfuse&lt;/value&gt;
&lt;/property&gt;
&lt;property name=”username”&gt;&lt;value&gt;sa&lt;/value&gt;&lt;/property&gt;
&lt;property name=”password”&gt;&lt;value&gt;&lt;/value&gt;&lt;/property&gt;
</blockquote>
<p>
&lt;/bean&gt;
六、Spring里面applicationContext.xml文件能不能改成其他文件名？
<a href="ContextLoaderListener.html">ContextLoaderListener</a>是一个<a href="ServletContextListener.html">ServletContextListener</a>, 它在你的web应用启动的时候初始化。缺省情况下， 它会在WEB-INF/applicationContext.xml文件找Spring的配置。 你可以通过定义一个&lt;context-param&gt;元素名字为”contextConfigLocation”来改变Spring配置文件的位置。示例如下：
&lt;listener&gt;
</p>
<blockquote>
&lt;listener-class&gt;org.springframework.web.context.<a href="ContextLoaderListener.html">ContextLoaderListener</a>
&lt;context-param&gt;
&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
&lt;param-value&gt;/WEB-INF/xyz.xml&lt;/param-value&gt;
&lt;/context-param&gt;
&lt;/listener-class&gt;
</blockquote>
<p>
&lt;/listener&gt;
七、如何在web应用里面配置spring?
在web.xml中加入如下同容,在启动web服务器时加载/WEB-INF/applicationContext.xml中的内容。
&lt;servlet&gt;
&lt;servlet-name&gt;context&lt;/servlet-name&gt;
&lt;servlet-class&gt;
org.springframework.web.context.<a href="ContextLoaderServlet.html">ContextLoaderServlet</a>
&lt;/servlet-class&gt;
&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
通过如下类得到<a href="ApplicationContext.html">ApplicationContext</a>实例
</p>
<blockquote>
<a href="WebApplicationContextUtils.html">WebApplicationContextUtils</a>.getWebApplicationContext
</blockquote>
<p>
八、Spring里面如何定义hibernate mapping？
添加hibernate mapping 文件到web/WEB-INF目录下的applicationContext.xml文件里面。示例如下：
&lt;property name=”mappingResources”&gt;
</p>
<blockquote>
&lt;list&gt;
&lt;value&gt;org/appfuse/model/User.hbm.xml&lt;/value&gt;
&lt;/list&gt;
</blockquote>
<p>
&lt;/property&gt;
九、解释一下Dependency injection(DI,依赖注入)和IOC(Inversion of control,控制反转)?
依赖注入DI是一个程序设计模式和架构模型， 一些时候也称作控制反转，尽管在技术上来讲，依赖注入是一个IOC的特殊实现，依赖注入是指一个对象应用另外一个对象来提供一个特殊的能力，例如：把一个数据库连接已参数的形式传到一个对象的结构方法里面而不是在那个对象内部自行创建一个连接。控制反转和依赖注入的基本思想就是把类的依赖从类内部转化到外部以减少依赖
应用控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用，传递给它。也可以说，依赖被注入到对象中。所以，控制反转是，关于一个对象如何获取他所依赖的对象的引用，这个责任的反转。
十、spring中的<a href="BeanFactory.html">BeanFactory</a>与<a href="ApplicationContext.html">ApplicationContext</a>的作用有哪些？
1. <a href="BeanFactory.html">BeanFactory</a>负责读取bean配置文档，管理bean的加载，实例化，维护bean之间的依赖关系，负责bean的声明周期。
2. <a href="ApplicationContext.html">ApplicationContext</a>除了提供上述<a href="BeanFactory.html">BeanFactory</a>所能提供的功能之外，还提供了更完整的框架功能：
a. 国际化支持
b. 资源访问：Resource rs = ctx. getResource(”classpath:config.properties”), “file:c:/config.properties”
c. 事件传递：通过实现<a href="ApplicationContextAware.html">ApplicationContextAware</a>接口
3. 常用的获取<a href="ApplicationContext.html">ApplicationContext</a>的方法：
<a href="FileSystemXmlApplicationContext.html">FileSystemXmlApplicationContext</a>：从文件系统或者url指定的xml配置文件创建，参数为配置文件名或文件名数组
<a href="ClassPathXmlApplicationContext.html">ClassPathXmlApplicationContext</a>：从classpath的xml配置文件创建，可以从jar包中读取配置文件
<a href="WebApplicationContextUtils.html">WebApplicationContextUtils</a>：从web应用的根目录读取配置文件，需要先在web.xml中配置，可以配置监听器或者servlet来实现
&lt;listener&gt;
&lt;listener-class&gt;org.springframework.web.context.<a href="ContextLoaderListener.html">ContextLoaderListener</a>&lt;/listener-class&gt;
&lt;/listener&gt;
&lt;servlet&gt;
&lt;servlet-name&gt;context&lt;/servlet-name&gt;
&lt;servlet-class&gt;org.springframework.web.context.<a href="ContextLoaderServlet.html">ContextLoaderServlet</a>&lt;/servlet-class&gt;
&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
这两种方式都默认配置文件为web-inf/applicationContext.xml，也可使用context-param指定配置文件
&lt;context-param&gt;
&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
&lt;param-value&gt;/WEB-INF/myApplicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;
十一、如何在web环境中配置applicationContext.xml文件?
&lt;listener&gt;
   &lt;listener-class&gt;
</p>
<blockquote>
org.springframework.web.context.<a href="ContextLoaderListener.html">ContextLoaderListener</a>
</blockquote>
<p>
   &lt;/listener-class&gt;
&lt;/listener&gt;
或：
&lt;servlet&gt;
   &lt;servlet-name&gt;context&lt;/servlet-name&gt;
</p>
<blockquote>
&lt;servlet-class&gt;
org.springframework.web.context.<a href="ContextLoaderServlet.html">ContextLoaderServlet</a>
&lt;/servlet-class&gt;
</blockquote>
<p>
   &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
通过如下方法取出applicationContext实例:
<a href="ApplicationContext.html">ApplicationContext</a> ac=<a href="WebApplicationContextUtils.html">WebApplicationContextUtils</a>.getWebApplicationContext(this.getServletContext);
十二、如何配置spring+struts?
在struts-config.xml加入一个插件，通过它加载applicationContext.xml
? 在struts-config.xml修改action-mapping标记，具体action交给了<a href="DelegateActionProxy.html">DelegateActionProxy</a>
? 通过<a href="DelegateActionProxy.html">DelegateActionProxy</a>进入一spring的环境。
? 在spring的applicationContext.xml加入&lt;bean name=”/login” class=”" singleton=”false”/&gt;
十三、spring+hibernate的配置文件中的主要类有那些?如何配置?
dataSource
   sessionFactory:hibernate.cfg.xml
   transactionManager
   userDao (extends <a href="HibernateDaoSupport.html">HibernateDaoSupport</a>) 
   sessionFactory
   facade
   proxy
   sessionFactory
   transactionManager
   facade
在myeclipse中先加入spring环境再加入hibernate环境。
如果spring与hibernate结合在一起可以不需要hibernate.cfg.xml文件是否正确
十四、如何在spring中实现国际化?
在applicationContext.xml加载一个bean
&lt;bean id=”messageSource” class=”org.springframework.context.support.<a href="ResourceBundleMessageSource.html">ResourceBundleMessageSource</a>”&gt;
   &lt;property name=”basename”&gt;
</p>
<blockquote>
&lt;value&gt;message&lt;/value&gt;
</blockquote>
<p>
   &lt;/property&gt;
&lt;/bean&gt;
? 在src目录下建多个properties文件
? 对于非英文的要用native2ascii -encoding gb2312 源 目转化文件相关内容
? 其命名格式是message_语言_国家。
? 页面中的中显示提示信息，键名取键值。
? 当给定国家，系统会自动加载对应的国家的properties信息。
? 通过applictionContext.getMessage(“键名”,”参数”,”区域”)取出相关的信息。
十五、spring中的核心类有那些，各有什么作用?
<a href="BeanFactory.html">BeanFactory</a>：产生一个新的实例，可以实现单例模式
<a href="BeanWrapper.html">BeanWrapper</a>：提供统一的get及set方法
<a href="ApplicationContext.html">ApplicationContext</a>:提供框架的实现，包括<a href="BeanFactory.html">BeanFactory</a>的所有功能
十六、什么是aop，aop的作用是什么?
面向切面编程（AOP）提供另外一种角度来思考程序结构，通过这种方式弥补了面向对象编程（OOP）的不足
除了类（classes）以外，AOP提供了切面。切面对关注点进行模块化，例如横切多个类型和对象的事务管理
Spring的一个关键的组件就是AOP框架，可以自由选择是否使用AOP
提供声明式企业服务，特别是为了替代EJB声明式服务。最重要的服务是声明性事务管理，这个服务建立在Spring的抽象事物管理之上
允许用户实现自定义切面，用AOP来完善OOP的使用
可以把Spring AOP看作是对Spring的一种增强
十七、使用Spring有什么好处？
◆Spring能有效地组织你的中间层对象,无论你是否选择使用了EJB。如果你仅仅使用了Struts或其他的包含了J2EE特有APIs的framework，你会发现Spring关注了遗留下的问题，。
◆Spring能消除在许多工程上对Singleton的过多使用。根据我的经验，这是一个主要的问题，它减少了系统的可测试性和面向对象特性。
◆Spring能消除使用各种各样格式的属性定制文件的需要,在整个应用和工程中，可通过一种 一致的方法来进行配置。曾经感到迷惑，一个特定类要查找迷幻般的属性关键字或系统属性,为此不得不读Javadoc乃至源编码吗？有了Spring，你可 很简单地看到类的<a href="JavaBean.html">JavaBean</a>属性。倒置控制的使用(在下面讨论)帮助完成这种简化。
◆Spring能通过接口而不是类促进好的编程习惯，减少编程代价到几乎为零。
◆Spring被设计为让使用它创建的应用尽可能少的依赖于他的APIs。在Spring应用中的大多数业务对象没有依赖于Spring。
◆使用Spring构建的应用程序易于单元测试。
◆Spring能使EJB的使用成为一个实现选择,而不是应用架构的必然选择。你能选择用POJOs或local EJBs来实现业务接口，却不会影响调用代码。
◆Spring帮助你解决许多问题而无需使用EJB。Spring能提供一种EJB的替换物，它们适于许多web应用。例如,Spring能使用AOP提供声明性事务而不通过使用EJB容器，如果你仅仅需要与单个的数据库打交道，甚至不需要JTA实现。
■Spring为数据存取提供了一致的框架,不论是使用JDBC或O/R mapping产品（如Hibernate）。
Spring确实使你能通过最简单可行的解决办法解决你的问题。这些特性是有很大价值的。
总结起来，Spring有如下优点：
◆低侵入式设计，代码污染极低
◆ 独立于各种应用服务器，可以真正实现Write Once,Run Anywhere的承诺
◆Spring的DI机制降低了业务对象替换的复杂性
◆Spring并不完全依赖于Spring，开发者可自由选用Spring框架的部分或全部
十八、什么是Spring, 它有什么特点？
Spring是一个轻量级的控制反转(<a href="IoC.html">IoC</a>)和面向切面(AOP)的容器框架。
◆轻量――从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并 且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。
◆控制反转――Spring通过一种称作控制反转（<a href="IoC.html">IoC</a>）的技术促进了松耦 合。当应用了<a href="IoC.html">IoC</a>，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为<a href="IoC.html">IoC</a>与JNDI相反――不 是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。
◆面向切面――Spring提供了面向切面编程的丰富支持，允许通过分离应用的 业务逻辑与系统级服务（例如审计（auditing）和事务（）管理）进行内聚性的开发。应用对象只实现它们应该做的――完成业务逻辑――仅此而已。它们 并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。
◆容器――Spring包含并管理应用对象的配置和生命周期，在这个意义上它是 一种容器，你可以配置你的每个bean如何被创建――基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生 成一个新的实例――以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。
◆框架――Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。
十九、请介绍一下Spring框架中Bean的生命周期
一、Bean的定义
Spring通常通过配置文件定义Bean。如：
&lt;?xml version=”1.0″ encoding=”UTF-8″?&gt;
&lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>”
xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>”
xsi:schemaLocation=”<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a> <a href="http://www.springframework.org/schema/beans/spring-beans-2.0.xsd">http://www.springframework.org/schema/beans/spring-beans-2.0.xsd</a>”&gt;
&lt;bean id=”<a href="HelloWorld.html">HelloWorld</a>” class=”com.pqf.beans.<a href="HelloWorld.html">HelloWorld</a>”&gt;
&lt;property name=”msg”&gt;
&lt;value&gt;<a href="HelloWorld.html">HelloWorld</a>&lt;/value&gt;
&lt;/property&gt;
&lt;/bean&gt;
&lt;/beans&gt;
这个配置文件就定义了一个标识为 <a href="HelloWorld.html">HelloWorld</a> 的Bean。在一个配置文档中可以定义多个Bean。
二、Bean的初始化
有两种方式初始化Bean。
1、在配置文档中通过指定init-method 属性来完成
在Bean的类中实现一个初始化Bean属性的方法，如init()，如：
public class <a href="HelloWorld.html">HelloWorld</a>{
public String msg=null;
public Date date=null;
public void init() {
msg=”<a href="HelloWorld.html">HelloWorld</a>”;
date=new Date();
}
……
}
然后，在配置文件中设置init-mothod属性：
&lt;bean id=”<a href="HelloWorld.html">HelloWorld</a>” class=”com.pqf.beans.<a href="HelloWorld.html">HelloWorld</a>” init-mothod=”init” &gt;
&lt;/bean&gt;
2、实现 org.springframwork.beans.factory.<a href="InitializingBean.html">InitializingBean</a>接口
Bean实现<a href="InitializingBean.html">InitializingBean</a>接口，并且增加 afterPropertiesSet() 方法：
public class <a href="HelloWorld.html">HelloWorld</a> implement <a href="InitializingBean.html">InitializingBean</a> {
public String msg=null;
public Date date=null;
public void afterPropertiesSet() {
msg=”向全世界问好！”;
date=new Date();
}
……
}
那么，当这个Bean的所有属性被Spring的<a href="BeanFactory.html">BeanFactory</a>设置完后，会自动调用afterPropertiesSet()方法对Bean进行初始化，于是，配置文件就不用指定 init-method属性了。
三、Bean的调用
有三种方式可以得到Bean并进行调用：
1、使用<a href="BeanWrapper.html">BeanWrapper</a>
<a href="HelloWorld.html">HelloWorld</a> hw=new <a href="HelloWorld.html">HelloWorld</a>();
<a href="BeanWrapper.html">BeanWrapper</a> bw=new <a href="BeanWrapperImpl.html">BeanWrapperImpl</a>(hw);
bw.setPropertyvalue(”msg”,”<a href="HelloWorld.html">HelloWorld</a>”);
system.out.println(bw.getPropertyCalue(”msg”));
2、使用<a href="BeanFactory.html">BeanFactory</a>
<a href="InputStream.html">InputStream</a> is=new <a href="FileInputStream.html">FileInputStream</a>(”config.xml”);
<a href="XmlBeanFactory.html">XmlBeanFactory</a> factory=new <a href="XmlBeanFactory.html">XmlBeanFactory</a>(is);
<a href="HelloWorld.html">HelloWorld</a> hw=(<a href="HelloWorld.html">HelloWorld</a>) factory.getBean(”<a href="HelloWorld.html">HelloWorld</a>”);
system.out.println(hw.getMsg());
3、使用<a href="ApplicationConttext.html">ApplicationConttext</a>
<a href="ApplicationContext.html">ApplicationContext</a> actx=new <a href="FleSystemXmlApplicationContext.html">FleSystemXmlApplicationContext</a>(”config.xml”);
<a href="HelloWorld.html">HelloWorld</a> hw=(<a href="HelloWorld.html">HelloWorld</a>) actx.getBean(”<a href="HelloWorld.html">HelloWorld</a>”);
System.out.println(hw.getMsg());
四、Bean的销毁
1、使用配置文件中的 destory-method 属性
与初始化属性 init-methods类似，在Bean的类中实现一个撤销Bean的方法，然后在配置文件中通过 destory-method指定，那么当bean销毁时，Spring将自动调用指定的销毁方法。
2、实现 org.springframwork.bean.factory.<a href="DisposebleBean.html">DisposebleBean</a>接口
如果实现了<a href="DisposebleBean.html">DisposebleBean</a>接口，那么Spring将自动调用bean中的Destory方法进行销毁，所以，Bean中必须提供Destory方法。
二十、AOP里面重要的几个名词概念解释：
切面（Aspect）： 一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @Aspect 注解（@<a href="AspectJ.html">AspectJ</a>风格）来实现。 
连接点（Joinpoint）： 在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。 在Spring AOP中，一个连接点 总是 代表一个方法的执行。 通过声明一个org.aspectj.lang.<a href="JoinPoint.html">JoinPoint</a>类型的参数可以使通知（Advice）的主体部分获得连接点信息。 
通知（Advice）： 在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。 通知的类型将在后面部分进行讨论。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。 
切入点（Pointcut）： 匹配连接点（Joinpoint）的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。 切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用<a href="AspectJ.html">AspectJ</a>切入点语法。 
引入（Introduction）： （也被称为内部类型声明（inter-type declaration））。声明额外的方法或者某个类型的字段。 Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。 例如，你可以使用一个引入来使bean实现 <a href="IsModified.html">IsModified</a> 接口，以便简化缓存机制。 
目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做 被通知（advised） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。 
AOP代理（AOP Proxy）： AOP框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能）。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。 注意：Spring 2.0最新引入的基于模式（schema-based）风格和@<a href="AspectJ.html">AspectJ</a>注解风格的切面声明，对于使用这些风格的用户来说，代理的创建是透明的。 
织入（Weaving）： 把切面（aspect）连接到其它的应用程序类型或者对象上，并创建一个被通知（advised）的对象。 这些可以在编译时（例如使用<a href="AspectJ.html">AspectJ</a>编译器），类加载时和运行时完成。 Spring和其他纯Java AOP框架一样，在运行时完成织入。 
通知的类型：
前置通知（Before advice）： 在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。 
返回后通知（After returning advice）： 在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。 
抛出异常后通知（After throwing advice）： 在方法抛出异常退出时执行的通知。 
后通知（After (finally) advice）： 当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。 
环绕通知（Around Advice）： 包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。 
环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。
切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。 
一、Hibernate工作原理：
读取并解析配置文件 
读取并解析映射信息，创建<a href="SessionFactory.html">SessionFactory</a> 
打开Sesssion 
创建事务Transation 
持久化操作 
提交事务 
关闭Session 
关闭<a href="SesstionFactory.html">SesstionFactory</a> 
</p>
 
<p>
二、Hibernate有什么好处：
对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。 
Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作 
hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 
hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。 
</p>
 
<p>
三、Hibernate是如何延迟加载的：
Hibernate2延迟加载实现：a)实体对象 b)集合（Collection） 
Hibernate3 提供了属性的延迟加载功能  
四、Hibernate的查询方式：
Sql、Criteria,object comptosition 
Hql： 
属性查询 
参数查询、命名参数查询 
关联查询 
分页查询 
统计函数 
</p>
 
<p>
五、说下Hibernate的缓存机制：
</p>
  
<p>
使用双向一对多关联，不使用单向一对多 
灵活使用单向一对多关联 
不用一对一，用多对一取代 
配置对象缓存，不使用集合缓存 
一对多集合使用Bag,多对多集合使用Set 
继承类使用显式多态 
表字段要少，表关联不要怕多，有二级缓存撑腰  
</p>
 
 
 
<p>
内部缓存存在Hibernate中又叫一级缓存，属于应用事物级缓存 
二级缓存： 
六、如何优化Hibernate:
</p>
 
<p>
a)应用及缓存 
b)分布式缓存 
条件：数据不会被第三方修改、数据大小在可接受范围、数据更新频率低、同一数据被系统频繁使用、非关键数据 
c) 第三方缓存的实现 
}}}
</p>
        </div>
<div id="footer"><center>
            Copyright@2010 arch Powered by <a href="http://vimwiki.googlecode.com/">Vimwiki</a>
	 <script charset="Shift_JIS" src="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_wh.js"></script></center>
        </div>
    </body>
</html>
