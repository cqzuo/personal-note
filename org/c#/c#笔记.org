* 简介
** .Net Framework的功能和包含的内容
*** 特点
 - mono 多种操作系统
 - 支持多种语言
 - 可以作为集成各种操作系统的方式
*** 内容
 - CTS
 - CLR
*** 编写过程
**** CIL和JIT
 - 编译时将代码编译为CIL
 - JIT,在需要编译时才编译为目标机器代码
**** 程序集
 - CIL代码
   + 包括可以执行的应用程序文件和其他应用程序需要的库
 - 元信息
   + 程序集中保函的数据的信息
 - 可选资源
   + 声音文件和图片 
**** 托管代码
 - CLR管理的应用程序
   + 方式是内存管理,处理安全性已经允许跨语言调试
**** 垃圾回收
  - 有时需要自己执行垃圾回收检测
**** 组合
**** 链接 
*** 含义
 - 为.net开发的一种语言
** .Net 应用程序的工作原理
** c#的概率和.net的关系
** 开发工具
* 编写简单的c#程序
** 命令行程序
** windows form程序
* 变量和表达式
** 基本语法
 - 不考虑空格回车或tab
 - 每个语句都用一个分号来结束
 - 所有的语句都是代码库的一部分({})
 - 注释的方式
   + 开头或结尾
   + /* 注释内容  */ 
   + /// 可以导出为说明书
 - 区分大小写
** 变量及其用法
** 表达式及其用法
** 流程控制
  - & | 与 && || 的区别
   + && 性能更好,且如果前面的已经计算出结果false,就不考虑后面的计算了*  对象的生命周期
** 类型之间的转换
 - 显式
   + (目标类型)源类型
   + 溢出检查 checked / unchecked
 - Convert.to***
** 枚举类型
          enum orientation{
		north = 1,
		south = 2,
		east = 3,
		west = 4
	}
** 结构类型
 struct route{
		public orientation direction;
		public double distance;
	}
** 数组
** 字符串
* 函数
** 输出参数
 - 在函数执行完毕之后,该参数的值返回给函数调用中的使用变量
  + functionName(out  type param)
** 结构函数
 - 结构中的函数
** 重载
** 委托
 - 定义
   + 把引用存储为函数的类型
 - 除了直接调用函数之外,还可以通过委托调用
 - 委托是用返回类型和参数列表定义的变量
 - 给定的委托类型可以匹配类型和参数与委托定义相同的方法
* 调试和错误处理
* 对象
** 简介
   - 基本同java
   - 命名
    + 第一个字符必须是字母,下划线或@,其他的字符可以是数字
   - 命名规则
    + 简单使用camelCase
    + 复杂使用PascalCase
  - 类型的转换
    + Convert.toDouble('''');
** 构造阶段
 - 对象的实例化,由构造函数完成
 - 构造函数可以是私有或公有的
   1. 在类的外部不能使用私有的构造函数来实例化对象
   2. 没有公共构造函数的类不能在外部进行实例化
** 析构阶段
 - 删除对象时的清理,由析构函数完成
 - 不应依赖析构函数来释放对象实例使用的资源
** 静态和实例类成员
 - 静态构造函数
  + 一个类只能有一个静态的构造函数
  + 不能有访问修饰符
  + 不能有参数
  + 不能直接调用
 - 静态类
** oop技术
 - 接口
  +一般用Ｉ开头
  - IDisposable接口
   + 支持IDisposable接口的对象必须实现Dispose()方法
   + 立即释放资源
   + using关键字可以在代码库中初始化使用重要资源的对象,会在代码块末尾自动调用Dispose()方法
#+BEGIN_SRC c#
// 第一种方法
<ClassName> <variableName> = new <ClassName>();
using(<variableName>){
 .....
}
// 第二种方法
using(<ClassName> <variableName> = new <ClassName>()){
 ......
}
#+END_SRC
 - 继承
   + 派生类不能访问基类的私有成员
   + 第 三种可访问性 protected -- 只有派生类可访问

* 定义类
** 控制可访问性和继承的关键字
 - internal
   + 默认情况下类声明是内部的,只有当前项目中的代码才能访问它.
 - public 
   + 公共类,其他项目中代码可访问
 - abstract
   + 不能实例化,只能继承,可以有抽象成员
 - sealed
   + 密封的,不能再派生
 - 继承
 - 接口
#+BEGIN_SRC c#
// 继承
 public class myClass : MyBase {... }
// 接口和基类
 public class myClass : IMyInterface, MyBase{... }
#+END_SRC
** 构造函数
 - 私有构造函数
   + 类是不可创建的
 - 执行序列
   + 构造函数后 + :base(索引)
** 析构函数
 - ~前缀 + 类名称

* 定义类成员
** 成员定义
 - public 
   + 由任意代码访问
 - private 
   + 由类中的代码访问(默认关键字)
 - internal
   + 由定义它的程序集(项目)内部的代码访问
 - protected
   + 有类或派生类的代码访问
** 方法修饰
 - virtual 
   + 方法可以重写
 - abstract
   + 方法必须在非抽象的派生类中重写
 - override
   + 重写了基类方法
 - extern 
   + 方法定义放在其他地方
** 自动属性
#+BEGIN_SRC c#
 public int MyIntPot{get; set;}
#+END_SRC
** 隐藏基类成员
#+BEGIN_SRC c#
 public class myDrivedClass : MyBaseClass
{
 // 此处的方法是重写基类的方法,new 关键字可避免警告
  new public void doSomeThing()
  {}
}
#+END_SRC

** 调用重写或隐藏的基类方法
 - base调用基类方法
 - this 调用本地的方法

** 接口
  + 不允许使用访问修饰符
  + 不能包含代码体
  + 不能定义字段成员
  + 不能使用关键字定义
  + 定义成员是禁止的
 - 显示实现接口中的方法
  + I接口名称.接口方法()

** 代码折叠
#+BEGIN_SRC c#
 #region 代码段名称
  // 代码...
 #endregion
#+END_SRC

* 集合 比较 和转换
